<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>斐波那契数列(fibonacci sequence)的6种解法 | TEN-Z&#39;S BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Fibonacci" />
  
  
  
  
  <meta name="description" content="最近在刷Leetcode，目前在“Explore”中出了很多学习和面试的专题，刷了几个系列感觉非常不错。“斐波那契数列”是一个很经典的问题了，无论是讲解递归还是动态规划的文章中都时常能看到。可以用斐波那契数列求解的题目也有很多，比如“爬梯子”和“兔子繁殖”等经典问题。在此主要是记录一下解决“斐波那契数列”类似问题的6种思路。">
<meta name="keywords" content="Fibonacci">
<meta property="og:type" content="article">
<meta property="og:title" content="斐波那契数列(Fibonacci sequence)的6种解法">
<meta property="og:url" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/index.html">
<meta property="og:site_name" content="TEN-Z&#39;S BLOG">
<meta property="og:description" content="最近在刷Leetcode，目前在“Explore”中出了很多学习和面试的专题，刷了几个系列感觉非常不错。“斐波那契数列”是一个很经典的问题了，无论是讲解递归还是动态规划的文章中都时常能看到。可以用斐波那契数列求解的题目也有很多，比如“爬梯子”和“兔子繁殖”等经典问题。在此主要是记录一下解决“斐波那契数列”类似问题的6种思路。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci.jpg">
<meta property="og:image" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/telltrue.jpeg">
<meta property="og:image" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci_recursion.png">
<meta property="og:image" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci_memoization.png">
<meta property="og:image" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci_binets.PNG">
<meta property="og:updated_time" content="2019-07-07T06:47:45.460Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="斐波那契数列(Fibonacci sequence)的6种解法">
<meta name="twitter:description" content="最近在刷Leetcode，目前在“Explore”中出了很多学习和面试的专题，刷了几个系列感觉非常不错。“斐波那契数列”是一个很经典的问题了，无论是讲解递归还是动态规划的文章中都时常能看到。可以用斐波那契数列求解的题目也有很多，比如“爬梯子”和“兔子繁殖”等经典问题。在此主要是记录一下解决“斐波那契数列”类似问题的6种思路。">
<meta name="twitter:image" content="https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci.jpg">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-斐波那契数列-Fibonacci-sequence-的6种解法" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      斐波那契数列(Fibonacci sequence)的6种解法
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/" class="article-date">
	  <time datetime="2019-06-18T03:50:20.000Z" itemprop="datePublished">2019-06-18</time>
	</a>

      
    <a class="article-category-link" href="/categories/算法/">算法</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <img src="/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci.jpg" title="fibonacci_rabbit">
<p>　　最近在刷<strong>Leetcode</strong>，目前在“Explore”中出了很多学习和面试的专题，刷了几个系列感觉非常不错。<strong>“斐波那契数列”</strong>是一个很经典的问题了，无论是讲解递归还是动态规划的文章中都时常能看到。可以用斐波那契数列求解的题目也有很多，比如“爬梯子”和“兔子繁殖”等经典问题。在此主要是记录一下解决“斐波那契数列”类似问题的6种思路。</p>
<a id="more"></a>
<blockquote>
<p style="color:Darkorange">版权声明：本文为博主原创文章，未经博主允许不得转载。</p>

<p>本篇文章中的所有事例在我的github中均有完整的代码实现，链接为：<a href="https://github.com/ten-z/Fibonacci-Sequence" target="_blank" rel="noopener">https://github.com/ten-z/Fibonacci-Sequence</a></p>
</blockquote>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><blockquote><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……<br>在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*)。</p>
<footer><strong>百度百科中关于斐波那契数列的描述</strong></footer></blockquote>
<p>一般斐波那契数列相关的问题都是给出n求F(n)，下面解法也都是针对这种题型来的。</p>
<img src="/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/telltrue.jpeg" title="我是说真的">
<h1 id="1-方法一：递归-回溯-暴力解法（Recursion）"><a href="#1-方法一：递归-回溯-暴力解法（Recursion）" class="headerlink" title="1. 方法一：递归/回溯/暴力解法（Recursion）"></a>1. 方法一：递归/回溯/暴力解法（Recursion）</h1><p>由于斐波那契数列有很明确的递归关系(F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*))和递归终止条件(F(0)=0， F(1)=1，有的会用F(2)=1)。因此，很容易用递归暴力解决。</p>
<p>越抽象的问题用图来说明会比较容易理解，下面以计算f(4)为例，计算f(4)递归执行树如下图：</p>
<img src="/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci_recursion.png" title="fibonacci_recursion">
<p>通过这个图以及递归关系很容易看出，递归的逻辑是：要求f(n)，就要先求出f(n-1)和f(n-2)的值；而求f(n-1)，又要先求出f(n-2)和f(n-3)的值，这样一步一步往前寻找，直到找到f(1)=1和f(2)=1为止。具体代码实现如下：</p>
<figure class="highlight plain"><figcaption><span>递归解法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int fibonacci(int n) &#123;</span><br><span class="line">  if (n &lt; 2) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(2^n)$<br>空间复杂度：$O(n)$</p>
<h1 id="2-方法二：记忆化搜索（Recursion-with-Memoization）"><a href="#2-方法二：记忆化搜索（Recursion-with-Memoization）" class="headerlink" title="2. 方法二：记忆化搜索（Recursion with Memoization）"></a>2. 方法二：记忆化搜索（Recursion with Memoization）</h1><p>记忆化搜索本质是对递归算法的剪枝优化。还是以计算f(4)为例，下图为计算f(4)的递归执行树，可以看出求解f(4)时存在着大量的重复计算：</p>
<img src="/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci_memoization.png" title="fibonacci_memoization">
<p>为了解决这些重复计算，可以将第一次求出的结果存储起来，一般来讲是按下标存放在memo数组中。下次计算前先去数组相应位置查找，如果有结果，就可直接返回，避免重复的计算。<br>代码也很简单：<br><figure class="highlight plain"><figcaption><span>记忆化搜索</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public static int fibonacci(int n) &#123;</span><br><span class="line">	if(n&lt;2)return n;</span><br><span class="line"></span><br><span class="line">	//初始化memo数组,从1～n，所以长度为n+1</span><br><span class="line">	int[] memo = new int[n+1];</span><br><span class="line">	return fibonacciMemorize(n, memo);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">//用memo数组存储计算结果</span><br><span class="line">public static int fibonacciMemorize(int n, int[] memo) &#123;</span><br><span class="line">	if(n==1 || n==2)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//如果memo(n)有值，直接返回memo[n]，减少递归次数，由于n从1开始，memo[0]=0不受影响。</span><br><span class="line">	if(memo[n]==0)&#123;</span><br><span class="line">		//如果当前f(n)没被计算过，则计算后将结果存入memo[n]</span><br><span class="line">		memo[n] = fibonacciMemorize(n-1, memo) + fibonacciMemorize(n-2, memo);</span><br><span class="line">	&#125;</span><br><span class="line">	return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<h1 id="3-方法三：动态规划（Dynamic-Programming）"><a href="#3-方法三：动态规划（Dynamic-Programming）" class="headerlink" title="3. 方法三：动态规划（Dynamic Programming）"></a>3. 方法三：动态规划（Dynamic Programming）</h1><p>根据动态规划的定义，由于这个问题可以分解成子问题，它包含了子问题的最优性质，即它的最优解可以从子问题的最优解中有效地构造出来。因此我们可以用动态规划来解决这个问题。</p>
<p>不过定义理解起来有点复杂，其实动态规划的解法可以看作是记忆化搜索思想的逆向思路。可以自行先打印下方法二中memo数组赋值的顺序，可以发现：<strong>memo数组是从memo[1]，memo[2],memo[3]…memo[n]依次赋值的，每一位置的值为前两个位置值的和。</strong>而memo[n]就是我们要求的f(n)。所以可见，如果抛弃递归的思路，仅在数组中用循环也可以依次计算数出组中的值，最后求得f(n)。具体点说，就是由于memo[1]=1和memo[2]=1可知，所以可以先算出memo[3] = memo[2] + memo[1],然后memo[4] = memo[3]+memo[2]…,直到求出memo[n]。而memo[n]就是要求的f(n)。</p>
<p>总结一下：递归和记忆化搜索的思路是：求f(n),要先求出f(n-1)和f(n-2)的值；而求f(n-1)，又要先求出f(n-2)和f(n-3)的值，这样一步一步往前寻找，直到找到f(1)=1和f(2)=1为止。<br>而动态规划的思路是：求f(n)，由于我们已经知道f(1) = 1,f(2) = 1，所以可以先求出f(3) = f(1) + f(2)，再求f(4)…这样一步一步从前向后直到求出f(n)。</p>
<p>代码如下：<br><figure class="highlight plain"><figcaption><span>动态规划，用循环代替了递归</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int fibonacciDynamic(int n) &#123;</span><br><span class="line">       if (n &lt; 2) &#123;</span><br><span class="line">           return n;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">//初始化memo数组,从1～n，所以长度为n+1</span><br><span class="line">       int[] memo = new int[n + 1];</span><br><span class="line"></span><br><span class="line">//已知的0和1位置的值，代替递归终止条件。</span><br><span class="line">       memo[0] = 0;</span><br><span class="line">       memo[1] = 1;</span><br><span class="line">	</span><br><span class="line">       for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">           memo[i] = memo[i - 1] + memo[i - 2];</span><br><span class="line">       &#125;</span><br><span class="line">//memo[n]即f(n)的值</span><br><span class="line">       return memo[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p>
<h1 id="4-方法四：斐波那契数（Fibonacci-Number）"><a href="#4-方法四：斐波那契数（Fibonacci-Number）" class="headerlink" title="4. 方法四：斐波那契数（Fibonacci Number）"></a>4. 方法四：斐波那契数（Fibonacci Number）</h1><p>这个方法本质是对方法三在空间复杂度上的优化。在动态规划的解法中，我们用了一个长度为n+1的memo数组来辅助计算f(n)，但是其实f(n)的值只跟f(n-1)和f(n-2)两个数有关，那么前面的n+1-3个数据能不能优化呢？</p>
<p>斐波那契数这个方法就是通过两个索引来代替memo数组，在每次循环之后更新两个索引的值，这样可以使空间复杂度降低至$O(1)$的级别。</p>
<p>废话不多说，上代码：<br><figure class="highlight plain"><figcaption><span>斐波那契数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public static int fibonacciNumber(int n) &#123;</span><br><span class="line">       if (n &lt; 2) &#123;</span><br><span class="line">           return n;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">//用first和second存储每次的memo[n-1]和memo[n-2],不断更新first和second的值，代替memo数组</span><br><span class="line">       int first = 0;</span><br><span class="line">       int second = 1;</span><br><span class="line">       for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">           int third = first + second;</span><br><span class="line">           first = second;</span><br><span class="line">           second = third;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">//最后一次循环交换后，f(n)==second</span><br><span class="line">       return second;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<p>斐波那契数列的常规方法主要就是上面四种，经过一步一步的优化，将时间复杂度降至O(n)，空间复杂度降至O(1)。后面介绍的两种特（qi）殊（pa）方法主要是针对时间复杂度的优化。</p>
<h1 id="5-方法五：矩阵法（Binets-Method）"><a href="#5-方法五：矩阵法（Binets-Method）" class="headerlink" title="5. 方法五：矩阵法（Binets Method）"></a>5. 方法五：矩阵法（Binets Method）</h1><p>矩阵法的本质是将斐波那契数列问题转化为指数计算的问题，而求解例如Q的n次方的问题可以很容易的使用二分法的思路，将时间复杂度降为$O(logn)$。<br>先看一下矩阵的乘法计算：<br>已知:<br>$$A=\left[\begin{matrix}a &amp; b\\c &amp; d\end{matrix}\right],<br>B=\left[\begin{matrix}e\\f\end{matrix}\right]$$<br>所以：<br>$$AB=\left[\begin{matrix}ae+bf\\ce+df\end{matrix}\right]<br>$$<br>反之亦然。</p>
<p>根据上面的规则，可以将斐波那次数列作如下改动：</p>
<p>$$\left[\begin{matrix}f(n)\\f(n-1)\end{matrix}\right]<br>=\left[\begin{matrix}f(n-1)+f(n-2)\\f(n-1)\end{matrix}\right]<br>=\left[\begin{matrix}f(n-1)×1+f(n-2)×1\\f(n-1)×1+f(n-2)×0\end{matrix}\right]<br>=\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]<br>×\left[\begin{matrix}f(n-1)\\f(n-2)\end{matrix}\right]$$</p>
<p>$$=….=\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]^{n-1}<br>×\left[\begin{matrix}f(1)\\f(0)\end{matrix}\right]<br>=\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]^{n-1}<br>×\left[\begin{matrix}1\\0\end{matrix}\right]$$</p>
<p>如果记$Q=\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]$，那么<br>$$\left[\begin{matrix}f(n)\\f(n-1)\end{matrix}\right]<br>=Q^{n-1}×\left[\begin{matrix}1\\0\end{matrix}\right]<br>$$<br>由于乘数是$\left[\begin{matrix}1\\0\end{matrix}\right]$，所以f(n)的值就是计算出$Q^{n-1}$的矩阵后最左上角那一位的值。</p>
<p><strong>如此，斐波那契数列就转换为了求Q的n-1次方的问题。</strong></p>
<p>求解$Q^{n-1}$的问题最主要的思路就是二分法，将指数n每次二分，根据当前n的奇偶不断递归，偶数就直接除以2，并将结果自己乘自己；奇数因为除不尽，结果还得再多乘一次Q。<br>当然，这里的乘法也是矩阵乘法，需要自己写出相应的方法。<br>示意图如下：</p>
<img src="/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/fibonacci_binets.PNG" title="fibonacci_binets">
<p>下面是具体代码：</p>
<figure class="highlight plain"><figcaption><span>矩阵法--指数二分</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   public static int fibonacci(int n, int[][] q) &#123;</span><br><span class="line">       if(n&lt;2)return n;</span><br><span class="line">       int[][] res = powRecursion(n-1, q);</span><br><span class="line">       return res[0][0];</span><br><span class="line">   &#125;</span><br><span class="line">   //递归实现的pow()，每次将指数二分</span><br><span class="line">   public static int[][] powRecursion(int n, int[][] q) &#123;</span><br><span class="line">       if(n == 1)return q;</span><br><span class="line">//每次指数/2</span><br><span class="line">       int[][] r = powRecursion(n&gt;&gt;1, q);</span><br><span class="line">//奇数的话要多乘一个底数，偶数则不用</span><br><span class="line">       if ((n &amp; 1) == 1)&#123;</span><br><span class="line">           return multiply(multiply(r,r), q);</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           return multiply(r,r);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //矩阵乘法的实现</span><br><span class="line">   public static int[][] multiply(int[][] a, int[][] b) &#123;</span><br><span class="line">       int[][] c = new int[2][2];</span><br><span class="line">       for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">           for (int j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">               c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>对于求解$Q^{n-1}$，或者说普遍求解$Q^{n}$这类问题，除了上面比较容易理解的递归之外，还可以利用二进制的一些技巧，将指数进行二进制的拆解。举个例子：</p>
<p>假设求：$Q^{11}$。我们已知11=1011=1000+0010+0001(拆解成二进制的和)<br>所以$$Q^{11}=Q^{8+2+1}=Q^8×Q^2×Q^1=Q^{2^3}×Q^{2^1}×Q^{2^0}$$</p>
<p>也就是说，将11转换成二进制，为1的位置就是底数要乘的位置，而由于二进制出现在幂的位置上，所以反应在Q上就变成前一位乘积的平方的关系。</p>
<p>逻辑稍有点复杂，还是上面的例子，为方便发现规律，假设Q = 3：<br>$$3^{0001}=3$$<br>$$3^{0010}= 3×3 = 9$$<br>$$3^{0100} = 9×9 = 81$$<br>$$3^{1000} = 81×81 = 6561$$<br>所以：<br>$$3^{1011} = 3×9×6561 = 177147$$</p>
<p><strong>具体执行逻辑为：</strong>将指数转换成二进制后，从右向左查看二进制每一位是否为1，如上所示，第一位为1，那么最终结果乘上$3^1$；继续看第二位，此时不用再计算$3^2$，直接将上一位（第一位）的结果自乘一下就是第二位的结果。同时由于第二位为1，最终结果也乘上第二位算出的结果；继续看第三位，也是一样的先计算出第三位的结果，由于第三位等于0，那么最终结果不乘入；到第四位，根据第三位的结果自乘算出第四位的结果，第四位是1，将第四位乘入最终结果。</p>
<p>写成代码就是如下的逻辑：<br><figure class="highlight plain"><figcaption><span>矩阵法--指数二进制拆分</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   public static int[][] powBinary(int n, int[][] a) &#123;</span><br><span class="line">//初始化矩阵,示意写法</span><br><span class="line">       int[][] ret = &#123;[1, 0&#125;], [0, 1]&#125;;</span><br><span class="line">       while (n &gt; 0) &#123;</span><br><span class="line">           if ((n &amp; 1) == 1) &#123;</span><br><span class="line">	//二进制中1的位置需要乘入结果，其结果等于低（前）一位结果的平方</span><br><span class="line">               ret = multiply(ret, a);</span><br><span class="line">           &#125;</span><br><span class="line">    //右移，看二进制指数高一位是否为1</span><br><span class="line">           n &gt;&gt;= 1;</span><br><span class="line">    //无论高一位是否为1，都先算出结果，等于当前结果的平方</span><br><span class="line">           a = multiply(a, a);</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：两种方法调用的时候是n-1：因为是$Q^{n-1}$。</strong></p>
<p>时间复杂度：$O(logn)$<br>空间复杂度：$O(1)$</p>
<h1 id="6-方法六：公式法（Fibonacci-Formula）"><a href="#6-方法六：公式法（Fibonacci-Formula）" class="headerlink" title="6. 方法六：公式法（Fibonacci Formula）"></a>6. 方法六：公式法（Fibonacci Formula）</h1><p>先给出第n项斐波那契数列f(n)的通项公式:<br>$$F_n=1/\sqrt{5}{\Bigl[<br>\Bigl(\frac{1+\sqrt{5}}{2}\Bigr)^n-<br>\Bigl(\frac{1-\sqrt{5}}{2}\Bigr)^n<br>\Bigr]}$$</p>
<p>Leetcode里给出的标准的推导方法是：<br>由于F(n+2) = F(n+1) + F(n)，假设$$F_n=a^n$$<br>可以得到：<br>$$a^{n+2}=a^{n+1}+a^n$$<br>简化下可得$a^{2}-a-1=0$,<br>这样a的解就是:$$a=\frac{1\pm\sqrt{5}}{2}$$<br>所以f(n)的通解为:<br>$$F_n=A\Bigl(\frac{1+\sqrt{5}}{2}\Bigr)^n+B\Bigl(\frac{1-\sqrt{5}}{2}\Bigr)^n$$</p>
<p>由于又知道两个特殊值：$f(0)=0;f(1)=1$，带入公式中可求出：<br>$$A=\frac{1}{\sqrt{5}}$$<br>$$B=-A=-\frac{1}{\sqrt{5}}$$</p>
<p>带入通项公式，可得：<br>$$F_n=1/\sqrt{5}{\Bigl[<br>\Bigl(\frac{1+\sqrt{5}}{2}\Bigr)^n-<br>\Bigl(\frac{1-\sqrt{5}}{2}\Bigr)^n<br>\Bigr]}$$</p>
<p>代码反而很简单：<br><figure class="highlight plain"><figcaption><span>通项公式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   public static int fibonacci(int n) &#123;</span><br><span class="line">if(n &lt; 2)</span><br><span class="line">	return n;</span><br><span class="line">	</span><br><span class="line">double sqrt5=Math.sqrt(5);</span><br><span class="line">       double fibn=Math.pow((1+sqrt5)/2,n)-Math.pow((1-sqrt5)/2,n);</span><br><span class="line">       return (int)(fibn/sqrt5);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：$O(logn)$–Math.pow()方法需要<br>空间复杂度：$O(1)$</p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>　　斐波那契数列的六种解法基本如上，后两种方法为了达到$O(logn)$级别的时间复杂度可谓是“不择手段”。多写两句，最近在刷算法题和复习基本的东西，感觉基础的东西确实需要好好看看。之前业务压力太大，甭说博客了，简单的总结时间都没有，睡眠也不太够。趁着最近调整调整，博客也要及时更新了。没有什么事情是很容易的，继续加油吧。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '谢谢你看我的博客。如果觉得我的文章对您有用，请随意打赏。', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: '/donate/images/wechat.jpg',
  alipayImage: '/donate/images/alibaba.jpg'
});
</script>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fibonacci/">Fibonacci</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/08/01/一起读RxJava源码（五）——线程调度/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">一起读RxJava源码（五）——线程调度</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-前言"><span class="nav-text">0. 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-方法一：递归-回溯-暴力解法（Recursion）"><span class="nav-text">1. 方法一：递归/回溯/暴力解法（Recursion）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-方法二：记忆化搜索（Recursion-with-Memoization）"><span class="nav-text">2. 方法二：记忆化搜索（Recursion with Memoization）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-方法三：动态规划（Dynamic-Programming）"><span class="nav-text">3. 方法三：动态规划（Dynamic Programming）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-方法四：斐波那契数（Fibonacci-Number）"><span class="nav-text">4. 方法四：斐波那契数（Fibonacci Number）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-方法五：矩阵法（Binets-Method）"><span class="nav-text">5. 方法五：矩阵法（Binets Method）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-方法六：公式法（Fibonacci-Formula）"><span class="nav-text">6. 方法六：公式法（Fibonacci Formula）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-总结"><span class="nav-text">7. 总结</span></a></li></ol>
    
    </div>
  </aside>


</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2018 - 2019 TEN-Z&#39;S BLOG All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>









	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            TEN-Z&#39;S BLOG
          </div>
          <div class="panel-body">
            Copyright © 2019 ten-z All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>
