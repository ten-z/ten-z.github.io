{"meta":{"title":"TEN-Z'S BLOG","subtitle":null,"description":"Thank you for reading my story","author":"ten-z","url":"https://ten-z.github.io"},"pages":[{"title":"关于我","date":"2018-03-18T06:11:26.000Z","updated":"2018-10-04T08:43:46.690Z","comments":false,"path":"about/index.html","permalink":"https://ten-z.github.io/about/index.html","excerpt":"","text":"The future is in your hands now. 随便写写♨ 说实话目的性不是很强，毕竟不是大神级的专业博主，主要是最近学习或者碰到问题的整理记录。♨ 文笔略强于小学生作文，如果觉得文字读不懂的……可以翻译成英文再试试。♨ 全部文章均为个人创作，少部分文字和图片会借鉴别人，坚决杜绝全篇抄袭。♨ 内容上以自己理解为主，如果有理解不对的地方，欢迎批评指正。 请多关照♨ 4年有余Android开发♨ 个人认为基础很重要，尤其是算法、数据结构和设计模式，是非常有助于深层次的学习的（尤其是看源码：RTFSC – Read The Fucking Source Code）。♨ 通信专业毕业，还有很多计算机专业基础等着要学。♨ 会一点H5(JS)、会一点Python、但目前主要的还是把Android和Java学好，当然，还有Kotlin。♨ 以后还需要学的东西可能会更多，看谷歌还能整出什么新玩意吧。 联系方式♨ Email: t_john@126.com♨ Github: https://github.com/ten-z♨ Blog: https://ten-z.github.io/ 膜拜大神这里是个人觉得对于学习很有帮助的大神的博客链接，当然主要是Android和Java的。♨ 郭霖的专栏：https://blog.csdn.net/guolin_blog/♨ Hongyang：https://blog.csdn.net/lmj623565791/♨ 胡凯：http://hukai.me/♨ HenCoder（扔物线）：http://hencoder.com/♨ 技术小黑屋：https://droidyue.com/♨ 刘望舒的博客: http://liuwangshu.cn/"},{"title":"categories","date":"2018-03-18T06:11:19.000Z","updated":"2018-04-25T15:25:40.015Z","comments":false,"path":"categories/index.html","permalink":"https://ten-z.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-18T06:11:02.000Z","updated":"2018-04-25T15:24:57.507Z","comments":false,"path":"tags/index.html","permalink":"https://ten-z.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一起读RxJava源码（五）——线程调度","slug":"一起读RxJava源码（五）——线程调度","date":"2018-08-01T15:28:14.000Z","updated":"2018-10-12T13:56:54.721Z","comments":true,"path":"2018/08/01/一起读RxJava源码（五）——线程调度/","link":"","permalink":"https://ten-z.github.io/2018/08/01/一起读RxJava源码（五）——线程调度/","excerpt":"经过前面四篇文章，我们已经了解了RxJava相关的一些基础。接下来，我们将进入RxJava最核心的内容—-线程调度。从Rx官网介绍来看，ReactiveX系列实现的核心功能就是异步编程，而程序层面中实现异步的核心是多线程。本篇文章内容稍长，如果稍有困惑可直接跳到文章末尾看流程图，可能会方便理解。","text":"经过前面四篇文章，我们已经了解了RxJava相关的一些基础。接下来，我们将进入RxJava最核心的内容—-线程调度。从Rx官网介绍来看，ReactiveX系列实现的核心功能就是异步编程，而程序层面中实现异步的核心是多线程。本篇文章内容稍长，如果稍有困惑可直接跳到文章末尾看流程图，可能会方便理解。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度 1. 线程调度的核心：Scheduler Scheduler本身就是调度程序、调度器的意思。这里把它称为“核心”是因为RxJava实现线程调度主要方式是将Scheduler作为参数传入相关操作符中实现的，比如一会要讲的SubscribeOn和ObserveOn。而在Rx官网介绍中，Scheduler本身就能实现多线程的相关功能。下面我们一起来看下。 1.1 Scheduler介绍 Scheduler是线程控制器，RxJava通过它来指定每一段代码应该运行在什么样的线程。RxJava已经内置了几个Scheduler，它们已经适合大多数的使用场景： Schedulers.immediate()：直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。 Schedulers.newThread()：总是启用新线程，并在新线程执行操作。 Schedulers.io()：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的Scheduler。这个计算指的是CPU密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为CPU核数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费CPU。 AndroidSchedulers.mainThread()：Android专用，它指定的操作将在Android主线程运行。 RxJava最常规的线程控制就是通过这几个Scheduler配合subscribeOn()和observeOn()两个方法来对线程进行控制。 1.2 单独使用Scheduler 除了将Scheduler传递给RxJava运算符之外，我们还可以单独使用Scheduler来安排自己的订阅工作。可以使用RxJava的Scheduler.Worker类实现Java中利用Thread实现的多线程功能：Scheduler实现多线程1234567891011Scheduler.Worker worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); &#125;&#125;);// some time later...worker.unsubscribe(); 在执行worker.schedule时会在新线程中执行call()中的代码。并可以通过worker.unsubscribe()终止线程。 之外，还可以实现延迟执行和周期执行： 延时500ms后执行 1someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS); 延时500ms后，每隔250ms执行一次 1someScheduler.schedulePeriodically(someAction，500,250，TimeUnit.MILLISECONDS); 2. 线程调度的基本实现 上一小节中提到过，RxJava实现线程控制主要是通过Scheduler配合subscribeOn()和observeOn()两个操作符来实现。下面简单介绍下这两个操作符的功能： subscribeOn(): 指定subscribe()所发生的线程，一方面是Observable.OnSubscribe被激活时所处的线程，或者叫做事件产生的线程。另一方面是观察者接收前的所处的线程，或者称为事件下发的线程。observeOn(): 指定Subscriber观察者所运行在的线程。或者叫做事件消费的线程。 定义如果没看太明白的话可以结合接下来的示例，下面是线程调度最基本的实现方式：线程调度基本实现1234567891011121314151617181920212223242526Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;hello rxjava&quot;); subscriber.onCompleted(); &#125;&#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); textView.setText(s); &#125; &#125;); 跟前几篇文章中基本方式比较，仅仅是多了.subscribeOn(Schedulers.io())和.observeOn(AndroidSchedulers.mainThread())两句。 在上面这段代码中，由于在create()后指定了subscribeOn(Schedulers.io())，Observable.OnSubscribe中call回调中的内容会在IO线程执行，即内容为”hello rxjava”的事件会在IO线程发出。而由于在subscribe()之前observeOn(AndroidScheculers.mainThread())的指定，使得Subscriber中给textView赋值的操作（UI的操作）会在主线程中执行。 通过对上面例子的解释可以看出，RxJava切换线程仅仅通过添加subscribeOn和observeOn操作符就能实现，并且可以通过多次调用observeOn实现多次切换线程。 能如此方便的切换线程，简直业界良心啊有木有。对于一名android搬砖工而言，可以不用纠结AsyncTask、线程和handler了。使用RxJava仅仅通过两个操作符就能实现线程间的切换、调度、可控，并大大减少代码量，增加可读性…… 当然，到此仅仅是介绍了RxJava实现线程调度的基本操作，下面我们就来分析分析源码，看看是怎么实现的。 3. 线程调度的源码解析——基于事件流 下面的讲解还是以线程调度的基本实现为例，但是这回我们讲解的顺序不按照绝大部分博客的思路——按代码顺序从上至下的方式进行。因为经过前两篇文章对基础源码的分析，我们发现RxJava在执行到subscribe()才会去产生事件并下发，所以这里我们以事件的产生到接收流程为顺序进行源码逻辑的分析，个人认为会更好理解一点。请再回顾一下刚才线程调度基本实现的代码，找到建立依赖关系的地方。 3.1 observeOn()源码解析（一） 先来分析下在subscribe()方法之前调用的observeOn()。这里是建立关系的开始，也是事件的开始。 先来看下observeOn()源码：observeOn()源码1234567891011121314public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, RxRingBuffer.SIZE);&#125;……public final Observable&lt;T&gt; observeOn(Scheduler scheduler, int bufferSize) &#123; return observeOn(scheduler, false, bufferSize);&#125;……public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return lift(new OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));&#125; 经历了层层调用后我们终于看到了observeOn()核心的东西，它调用了一个lift()方法。在上一篇文章最后我简单的介绍了一下：map原理的本质是lift。来看下lift()的源码:lift()源码123public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) &#123; return unsafeCreate(new OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));&#125; 可以看到和map()是几乎一模一样了，所以和map原理一样，lift本质也是创建了一个新的Observable。跟前面的文章一样，这里记为ObservableC……为什么是C，因为B在下一小节。这个ObservableC传入的OnSubscribe是一个OnSubscribeLift。下面就来看下这个OnSubscribeLift：OnSubscribeLift源码12345678910111213141516171819202122232425262728293031public final class OnSubscribeLift&lt;T, R&gt; implements OnSubscribe&lt;R&gt; &#123; final OnSubscribe&lt;T&gt; parent; final Operator&lt;? extends R, ? super T&gt; operator; public OnSubscribeLift(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? super T&gt; operator) &#123; this.parent = parent; this.operator = operator; &#125; @Override public void call(Subscriber&lt;? super R&gt; o) &#123; try &#123; Subscriber&lt;? super T&gt; st = RxJavaHooks.onObservableLift(operator).call(o); try &#123; // new Subscriber created and being subscribed with so &apos;onStart&apos; it st.onStart(); parent.call(st); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); st.onError(e); &#125; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); o.onError(e); &#125; &#125;&#125; 所以综上，当程序执行到observeOn(AndroidSchedulers.mainThread()).subscribe()，实际本质是在执行ObservableC.subscribe(new SubscriberD)。以后的逻辑就不多说了，相信看了前面两篇文章到这里基础应该十分扎实了。看下ObservableC——OnSubscribeLift的call()方法，RxJavaHooks.onObservableLift(operator)实际上就是将传入的operator返回了。并且调用了operator.call。这里的operator实际上是lift传入的参数OperatorObserveOn。下面来看下OperatorObserveOn.call：OperatorObserveOn的call方法12345678public Subscriber&lt;? super T&gt; call(Subscriber&lt;? super T&gt; child) &#123; ... ObserveOnSubscriber&lt;T&gt; parent = new ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize); parent.init(); return parent; &#125; 也是跟map一样，初始化了一个SubscriberC——ObserveOnSubscriber并调用init进行了初始化。下一步，回到OnSubscribeLift.Call中继续执行parent.call(st),也是就是调用了前一级Observable对应OnSubscriber.call(st)。注意这里和map有一点形式上的不一样，说是形式上是因为map这里是这样的：source.unsafeSubscribe(parent)，形式上是将上一级的Observable和本级的MapSubscriber建立了观察依赖，但实际起作用的其实是建立依赖后调用上一级的Observable的OnSubscriber.call,这里和observeOn()其实本质又一样了。因此，这里也可以看成执行了下面一句：1ObservableB.subscribe(SubscriberC) 于是，根据基本调用逻辑，事件又往上一级ObservableB去了。 3.2 subscribeOn()源码解析（一） 在线程调度的基本实现的例子中，在observeOn()方法之前调用的就是subscribeOn(Schedulers.io())，所以这一小节，我们来看下subscribeOn()的源码。subscribeOn()源码1123public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; return subscribeOn(scheduler, !(this.onSubscribe instanceof OnSubscribeCreate));&#125; subscribeOn()调用了一个两个参数的subscribeOn方法，我们继续：subscribeOn()源码2123456public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler, boolean requestOn) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return unsafeCreate(new OperatorSubscribeOn&lt;T&gt;(this, scheduler, requestOn));&#125; 重点在最后一句，如果你看了上一篇map()的源码解析，应该有印象：unsafeCreate()方法会创建一个新的被观察者Observable。由此可以预见，subscribeOn()的执行流程应该和map()差不多。这里会创建一个新的被观察者，记为ObservableB。传入的对应的OnSubscribe就是OperatorSubscribeOn。OperatorSubscribeOn源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public final class OperatorSubscribeOn&lt;T&gt; implements OnSubscribe&lt;T&gt; &#123; final Scheduler scheduler; final Observable&lt;T&gt; source; final boolean requestOn; public OperatorSubscribeOn(Observable&lt;T&gt; source, Scheduler scheduler, boolean requestOn) &#123; this.scheduler = scheduler; this.source = source; this.requestOn = requestOn; &#125; @Override public void call(final Subscriber&lt;? super T&gt; subscriber) &#123; final Worker inner = scheduler.createWorker(); SubscribeOnSubscriber&lt;T&gt; parent = new SubscribeOnSubscriber&lt;T&gt;(subscriber, requestOn, inner, source); subscriber.add(parent); subscriber.add(inner); inner.schedule(parent); &#125; static final class SubscribeOnSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; implements Action0 &#123; final Subscriber&lt;? super T&gt; actual; final boolean requestOn; final Worker worker; Observable&lt;T&gt; source; Thread t; SubscribeOnSubscriber(Subscriber&lt;? super T&gt; actual, boolean requestOn, Worker worker, Observable&lt;T&gt; source) &#123; this.actual = actual; this.requestOn = requestOn; this.worker = worker; this.source = source; &#125; @Override public void onNext(T t) &#123; actual.onNext(t); &#125; @Override public void onError(Throwable e) &#123; try &#123; actual.onError(e); &#125; finally &#123; worker.unsubscribe(); &#125; &#125; @Override public void onCompleted() &#123; try &#123; actual.onCompleted(); &#125; finally &#123; worker.unsubscribe(); &#125; &#125; @Override public void call() &#123; Observable&lt;T&gt; src = source; source = null; t = Thread.currentThread(); src.unsafeSubscribe(this); &#125; @Override public void setProducer(final Producer p) &#123; actual.setProducer(new Producer() &#123; @Override public void request(final long n) &#123; if (t == Thread.currentThread() || !requestOn) &#123; p.request(n); &#125; else &#123; worker.schedule(new Action0() &#123; @Override public void call() &#123; p.request(n); &#125; &#125;); &#125; &#125; &#125;); &#125; &#125;&#125; 通过上一小节我们知道事件经过observeOn后，会先调用ObservableB的OnSubscribe的call方法，这里即为OperatorSubscribeOn的call方法。 先简单过一下OperatorSubscribeOn的call中的代码的大概流程：首先通过scheduler.createWorker()构建了一个Worker；然后用传进来的subscriber构造了一个新的SubscribeOnSubscriber，记为subscriberB，并将subscriberB丢到Worker.schedule()创建的新线程来处理；新线程中，Worker.schedule(subscriberB)会执行subscriberB中的call方法，在call中会用上一级Observable去订阅观察者subscriberB，即ObservableA.subscribe(subscriberB)。提炼一下：切换线程，添加订阅ObservableA.subscribe(subscriberB)。 下面是详细的解析：第一步：final Worker inner = scheduler.createWorker(); 从上面的流程来看，这个Worker就是线程调度的关键，从前面1.2中的例子也能看出来，Worker本身就是用来创建新线程的。而在这个例子中，创建Worker的scheduler往上回溯去查找发现就是subscribeOn(Schedulers.io())中的Schedulers.io()，就是通过它创建了我们前面提到的Worker。所以下面来看看Schedulers.io()的实现：Schedulers.io()源码123public static Scheduler io() &#123; return RxJavaHooks.onIOScheduler(getInstance().ioScheduler);&#125; RxJavaHooks.onIOScheduler和绝大多数RxJavaHooks里的方法一样，把传入的scheduler返回了。这里的scheduler传入了一个getInstance().ioScheduler，看来是一个单例类，去它的私有构造器中找到ioScheduler的初始化：ioScheduler的初始化1234567891011private Schedulers() &#123; ... Scheduler io = hook.getIOScheduler(); if (io != null) &#123; ioScheduler = io; &#125; else &#123; ioScheduler = RxJavaSchedulersHook.createIoScheduler(); &#125; ... &#125; 继续看RxJavaSchedulersHook.createIoScheduler()：createIoScheduler()源码12345678910public static Scheduler createIoScheduler() &#123; return createIoScheduler(new RxThreadFactory(&quot;RxIoScheduler-&quot;));&#125;public static Scheduler createIoScheduler(ThreadFactory threadFactory) &#123; if (threadFactory == null) &#123; throw new NullPointerException(&quot;threadFactory == null&quot;); &#125; return new CachedThreadScheduler(threadFactory);&#125; 可以看到返回了一个CachedThreadScheduler。也就是说subscribeOn(Schedulers.io())中传入的scheduler实际是这个CachedThreadScheduler。Worker也是CachedThreadScheduler的createWorker()方法创建的：createWorker()源码1234@Overridepublic Worker createWorker() &#123; return new EventLoopWorker(pool.get());&#125; 这里返回了EventLoopWorker，OperatorSubscribeOn的call中第一句话的inner引用持有的Worker。用了这么长的篇幅终于把第一句解析完了，可见理解线程调度还是有一定难度的。下面的工作应该就是根据Worker创建线程了。 第二步：SubscribeOnSubscriber parent = new SubscribeOnSubscriber(subscriber, requestOn, inner, source); 继续到OperatorSubscribeOn源码解析上来。第二步就是普通的基本调用的套路：创建出subscriberB。具体就不解释了，可以参考map的讲解来看。 第三步：inner.schedule(parent); 第一步我们知道inner引用的对象实际是EventLoopWorker，来看下EventLoopWorker的schedule方法：EventLoopWorker的schedule源码12345678910111213141516171819202122@Override public Subscription schedule(Action0 action) &#123; return schedule(action, 0, null); &#125; @Override public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) &#123; ... ScheduledAction s = threadWorker.scheduleActual(new Action0() &#123; @Override public void call() &#123; if (isUnsubscribed()) &#123; return; &#125; action.call(); &#125; &#125;, delayTime, unit); innerSubscription.add(s); s.addParent(innerSubscription); return s; &#125;&#125; 看到它调用了ThreadWorker的scheduleActual()方法。这里的ThreadWorker引用的对象是NewThreadWorker，下面是它的scheduleActual():NewThreadWorker的scheduleActual()源码12345678910111213public ScheduledAction scheduleActual(final Action0 action, long delayTime, TimeUnit unit) &#123; Action0 decoratedAction = RxJavaHooks.onScheduledAction(action); ScheduledAction run = new ScheduledAction(decoratedAction); Future&lt;?&gt; f; if (delayTime &lt;= 0) &#123; f = executor.submit(run); &#125; else &#123; f = executor.schedule(run, delayTime, unit); &#125; run.add(f); return run;&#125; scheduleActual()中的ScheduledAction实现了Runnable接口，通过线程池executor切换了线程。顺便一提，可以在NewThreadWorker构造器中找到executor的初始化：NewThreadWorker源码123456789public NewThreadWorker(ThreadFactory threadFactory) &#123; ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, threadFactory); boolean cancelSupported = tryEnableCancelPolicy(exec); if (!cancelSupported &amp;&amp; exec instanceof ScheduledThreadPoolExecutor) &#123; registerExecutor((ScheduledThreadPoolExecutor)exec); &#125; executor = exec;&#125; 可以看到这里是一个容量为1的newScheduledThreadPool。 这里多说一句，这里只是说明NewThreadWorker是容量为1的newScheduledThreadPool。Schedulers.io()——也就是CachedThreadScheduler(threadFactory)，这个类维护了一个AtomicReference pool集合，集合中的每个元素都是一个NewThreadWorker。可以理解为线程池的缓存。 再回到EventLoopWorker的schedule方法中，我们知道threadWorker.scheduleActual启动了一个新的线程，线程会执行scheduleActual第一个参数——Action0的call方法。而这个call方法中执行了一行：action.call(); 往上层代码中查找发现这里的action就是subscriberB——SubscribeOnSubscriber。因此在SubscribeOnSubscriber代码中可以看到除了OnNext等方法之外还有一个call方法，而正常的subscriber是不应该有call方法的。这个call方法也是因为SubscribeOnSubscriber实现了Action0接口复写的。所以在action.call()中调用的就是SubscribeOnSubscriber里的call。具体代码请自行往上翻…… 在这个call中执行了src.unsafeSubscribe(this)。是的，就是ObservableA.subscribe(subscriberB)。 而ObservableA其实就是Observable.create()，也就是我们自己定义的被观察者。根据基本调用，会执行ObservableA中OnSubscribe的call方法，接着执行subscriberB.onNext(“hello rxjava”)。 所以，subscribeOn是先切换了线程，再去启动事件的，并且从启动事件开始，直到再次切换线程以前，都是在这个新线程中执行的。 下一步，来看下subscriberB——SubscribeOnSubscriber如何接收的。 3.3 subscribeOn()源码解析（二） 来看下subscribeOn()中创建的SubscribeOnSubscriber中接收事件的onNext方法：SubscribeOnSubscriber的onNext源码1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 好惊喜有木有，就TM一句啊……这里actual是OperatorSubscribeOn中call方法带入的，也就是subscriberC——在ObservableB.subscribe(SubscriberC)的时候传入的。 所以这里事件没有操作直接传往SubscriberC的onNext了……这甩锅甩的够快的…… 下面该进入SubscriberC的onNext了。 3.3 observeOn()源码解析（二） SubscriberC是在observeOn()中初始化的ObserveOnSubscriber，来看下源码：ObserveOnSubscriber源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static final class ObserveOnSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; implements Action0 &#123; …… @Override public void onNext(final T t) &#123; if (isUnsubscribed() || finished) &#123; return; &#125; if (!queue.offer(NotificationLite.next(t))) &#123; onError(new MissingBackpressureException()); return; &#125; schedule(); &#125; protected void schedule() &#123; if (counter.getAndIncrement() == 0) &#123; recursiveScheduler.schedule(this); &#125; &#125; // only execute this from schedule() @Override public void call() &#123; long missed = 1L; long currentEmission = emitted; final Queue&lt;Object&gt; q = this.queue; final Subscriber&lt;? super T&gt; localChild = this.child; for (;;) &#123; long requestAmount = requested.get(); while (requestAmount != currentEmission) &#123; boolean done = finished; Object v = q.poll(); boolean empty = v == null; if (checkTerminated(done, empty, localChild, q)) &#123; return; &#125; if (empty) &#123; break; &#125; localChild.onNext(NotificationLite.&lt;T&gt;getValue(v)); currentEmission++; if (currentEmission == limit) &#123; requestAmount = BackpressureUtils.produced(requested, currentEmission); request(currentEmission); currentEmission = 0L; &#125; &#125; if (requestAmount == currentEmission) &#123; if (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123; return; &#125; &#125; emitted = currentEmission; missed = counter.addAndGet(-missed); if (missed == 0L) &#123; break; &#125; &#125; &#125; &#125; 在ObserveOnSubscriber中执行了schedule()，而schedule()中执行了recursiveScheduler.schedule(this)。 来看下recursiveScheduler，在ObserveOnSubscriber构造器中有这么一句：this.recursiveScheduler = scheduler.createWorker(); 看到熟悉的createWorker()以及recursiveScheduler.schedule就知道这里要切换线程了。我们先等等，先看看这个scheduler引用的是啥。一层一层往上查找，发现就是observeOn(AndroidSchedulers.mainThread())传的AndroidSchedulers.mainThread()。再来看下这个方法：ObserveOnSubscriber源码123456789101112131415private AndroidSchedulers() &#123; RxAndroidSchedulersHook hook = RxAndroidPlugins.getInstance().getSchedulersHook(); Scheduler main = hook.getMainThreadScheduler(); if (main != null) &#123; mainThreadScheduler = main; &#125; else &#123; mainThreadScheduler = new LooperScheduler(Looper.getMainLooper()); &#125;&#125;/** A &#123;@link Scheduler&#125; which executes actions on the Android UI thread. */public static Scheduler mainThread() &#123; return getInstance().mainThreadScheduler;&#125; 所以执行scheduler.createWorker()的是LooperScheduler，而这个LooperScheduler(Looper.getMainLooper())传的参数是不是很熟悉？Looper.getMainLooper()获取主线程的Looper。 这里回到ObserveOnSubscriber中来，recursiveScheduler.schedule(this)切换到了主线程并执行this——也就是ObserveOnSubscriber的call方法。call方法中有两句localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));和checkTerminated(done, empty, localChild, q)：就是调用SubscriberD的onNext()、onCompleted()、onError()。 也就是说，observeOn是在之前的线程中接受事件，然后切换线程，这个例子是切换到主线程，然后在新线程（主线程）中下发事件给下一级的观察者。 到这里，线程调度的主要代码就介绍完了，下面看下整体流程。 4. 线程调度整体流程 请回忆线程调度基本实现代码，然后再来看下面的流程。 第一步：Observable.create，创建被观察者，记为ObservableA第二步：.subscribeOn(Schedulers.io())，创建新被观察者，记为ObservableB第三步：.observeOn(AndroidSchedulers.mainThread())，创建新被观察者，记为ObservableC第四步：.subscribe(new Subscriber())，创建观察者，记为SubscriberD，并建立依赖关系：ObservableC.subscribe(SubscriberD) 第五步：创建新观察者ObserveOnSubscriber，记为SubscriberC。并建立新依赖关系ObservableB.subscribe(SubscriberC)第六步：通过制定Scheduler创建Worker；创建新观察者SubscribeOnSubscriber，记为SubscriberB；worker.schedule()切换新线程；在新线程中执行ObservableA.subscribe(SubscriberB) 第七步：ObservableA中OnSubscribe的call开始发送事件”hello rxjava” 第八步：SubscriberB接到事件后，直接甩给SubscriberC第九步：SubscriberC接收事件；通过Worker切换到主线程；在主线程中将事件传递给SubscriberD第十步：SubscriberD接收事件，整体流程结束 根据流程我们可以简单总结为：subscribeOn在事件上行时切换线程，而observeOn是在事件下发时切换线程。自己画了张图，加深理解： 5. 总结 线程调度到这里就告一段落了，我讲的也是寥寥数语，只是把大体流程介绍了一遍。如果想仔细搞懂每一步的细节，还需要在多线程以及handler机制上下功夫。 我们经过这几篇的介绍,RxJava源码主要的逻辑基本介绍完了。下一章会介绍一些较为轻松的RxJava的具体应用，敬请期待！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（四）——转换操作符","slug":"一起读RxJava源码（四）——转换操作符","date":"2018-06-24T13:20:25.000Z","updated":"2018-10-11T15:37:43.788Z","comments":true,"path":"2018/06/24/一起读RxJava源码（四）——转换操作符/","link":"","permalink":"https://ten-z.github.io/2018/06/24/一起读RxJava源码（四）——转换操作符/","excerpt":"上一篇我们介绍了RxJava最基本的实现方式以及源码逻辑，但是仅仅会基础实现方式是远远不够的。RxJava有着大量的各式各样的操作符（如上图谱所示）。也正是因为这些操作符，使得RxJava可以很简单且简洁的实现一些复杂的问题。这也是RxJava以至于Rx系列强大的原因之一。","text":"上一篇我们介绍了RxJava最基本的实现方式以及源码逻辑，但是仅仅会基础实现方式是远远不够的。RxJava有着大量的各式各样的操作符（如上图谱所示）。也正是因为这些操作符，使得RxJava可以很简单且简洁的实现一些复杂的问题。这也是RxJava以至于Rx系列强大的原因之一。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度 1. 前言 上一篇我们介绍的RxJava最基本的实现方式虽然没有展现出RxJava的强大，但是却是一切的基础。没有看过的工友建议先看下，以免这一章节消化不了。 RxJava的操作符有很多，上面的图谱里就能看出来，具体使用可以参考官网介绍。这里主要介绍的是转换操作符，它作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。直接看概念可能会不太好理解，这篇文章以相对简单且常用的转换操作符map为例，进行源码的分析。了解map操作符的逻辑之后可能再来看概念就容易理解得多了。 转换操作符实现的其实是“变换”的原理。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 ——转换操作符原理 2. map操作符的简单应用 先举个例子，将一组字符串中的小写字符转换成大写输出，用map可以这样实现：map实现字符串中小写转大写12345678910111213141516171819202122232425262728List&lt;String&gt; froms = new ArrayList&lt;&gt;();froms.add(&quot;hello&quot;);froms.add(&quot;rxjava&quot;);froms.add(&quot;毁我青春&quot;);Observable.from(froms) .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.toUpperCase(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; //System.out.println(&quot;onCompleted&quot;); Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); &#125; &#125;); 输出的结果是这样的：输出结果1234onNext=HELLOonNext=RXJAVAonNext=毁我青春onCompleted 这里Observable.from()这个方法是将传入的数组或Iterable拆分成具体对象后，依次发送出来。和之前的之前的create(OnSubscribe)是等价的。 可以看到，map()方法将每次接收到的String对象进行了toUpperCase()操作，经过map()方法后，Subscriber里onNext()收到的就是转换成大写的内容。当然，map()方法也可以进行其他类型的转换，比如将int转换成字符串，或是字符串转换成Bitmap对象等，在Func1类构造函数的泛型参数(new Func1&lt;String, String&gt;())就是转换前和转换后的对象类型。 总结一下map()的用法：它是对事件对象一对一的直接变换，也是RxJava最常用的变换。如下图所示： 3. map操作符的源码解析为了基于上一章节所讲的内容，我们把上面的例子变得简单一点：RxJava基本实现+map123456789101112131415161718192021222324252627Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;hello rxjava&quot;); subscriber.onCompleted(); &#125;&#125;).map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.toUpperCase(); &#125;&#125;).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); &#125;&#125;); 由于上一章节讲解了Observable.create()和.subscribe()的源码，所以这里用了上一章节介绍的RxJava基本实现。from()的源码解析这里就不多赘述了，主要还是理解map的基本的逻辑。 这里Observable.create()自然不必多说，最终返回了一个新创建的被观察者Observable。下一步会执行Observable.map()。 map()的源码也在Observable类里：map()源码123public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) &#123; return unsafeCreate(new OnSubscribeMap&lt;T, R&gt;(this, func));&#125; 再看下unsafeCreate()的类：unsafeCreate()源码123public static &lt;T&gt; Observable&lt;T&gt; unsafeCreate(OnSubscribe&lt;T&gt; f) &#123; return new Observable&lt;T&gt;(RxJavaHooks.onCreate(f));&#125; 是不是有点眼熟？？因为跟Observable.create()的实现是一毛一样的啊！可以现在回到上一章节对比一下。也就是说，map()方法也是直接返回了一个新创建的被观察者Observable，这是一个新的被观察者，我们把它称为ObservableB；一开始通过Observable.create()创建的Observable我们称之为ObservableA。 我们可以看到在ObservableB中，传入RxJavaHooks.onCreate(f)的参数可以追溯到map()方法里传入的new OnSubscribeMap(this, func)。所以，ObservableB对应的OnSubscribe就是这个OnSubscribeMap。而ObservableA和变换函数Func1则作为构造OnSubscribeMap的参数。 现在我们现在把视野拉远，从整体再看下这个例子的逻辑： 也就是说，在执行了map方法后，变成了ObservableB和Subscriber建立订阅关系。我们把最后的观察者也起个名子区分，叫SubscriberC。总结下，就是原本ObservableA.subscribe(SubscriberC)之间加了.map()后，现在变成了ObservableB.subscribe(SubscriberC)。 根据上一篇文章介绍的RxJava基础流程，在ObservableB.subscribe(SubscriberC)建立订阅关系后，应该执行ObservableB的onSubscribe里的call方法。上面讲到了 ObservableB对应的OnSubscribe是OnSubscribeMap，我们来看一下OnSubscribeMap的源码： OnSubscribeMap源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public final class OnSubscribeMap&lt;T, R&gt; implements OnSubscribe&lt;R&gt; &#123; final Observable&lt;T&gt; source; final Func1&lt;? super T, ? extends R&gt; transformer; public OnSubscribeMap(Observable&lt;T&gt; source, Func1&lt;? super T, ? extends R&gt; transformer) &#123; this.source = source; this.transformer = transformer; &#125; @Override public void call(final Subscriber&lt;? super R&gt; o) &#123; MapSubscriber&lt;T, R&gt; parent = new MapSubscriber&lt;T, R&gt;(o, transformer); o.add(parent); source.unsafeSubscribe(parent); &#125; static final class MapSubscriber&lt;T, R&gt; extends Subscriber&lt;T&gt; &#123; final Subscriber&lt;? super R&gt; actual; final Func1&lt;? super T, ? extends R&gt; mapper; boolean done; public MapSubscriber(Subscriber&lt;? super R&gt; actual, Func1&lt;? super T, ? extends R&gt; mapper) &#123; this.actual = actual; this.mapper = mapper; &#125; @Override public void onNext(T t) &#123; R result; try &#123; result = mapper.call(t); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); unsubscribe(); onError(OnErrorThrowable.addValueAsLastCause(ex, t)); return; &#125; actual.onNext(result); &#125; @Override public void onError(Throwable e) &#123; if (done) &#123; RxJavaHooks.onError(e); return; &#125; done = true; actual.onError(e); &#125; @Override public void onCompleted() &#123; if (done) &#123; return; &#125; actual.onCompleted(); &#125; @Override public void setProducer(Producer p) &#123; actual.setProducer(p); &#125; &#125;&#125; OnSubscribeMap实现了OnSubscribe接口，因此OnSubscribeMap就是一个OnSubscribe。我们来看下OnSubscribeMap的call方法。首先通过我们的观察者o(即SubscriberC)和转换函数transformer构造了一个MapSubscriber。然后调用了source的unsafeSubscribe(）。 我们看下这个source是从OnSubscribeMap(Observable&lt;T&gt; source, Func1&lt;? super T, ? extends R&gt; transformer)这个构造器里传过来的。往上一级看，这个构造器是在ObservableA.map()方法里调用的（具体源码请往上翻到map()源码），这里source传入的就是ObservableA。 所以这里小结下，OnSubscribeMap的call方法里本质是调用了ObservableA的unsafeSubscribe()。我们继续深入，看下unsafeSubscribe()源码： unsafeSubscribe()源码12345678910111213141516171819202122232425public final Subscription unsafeSubscribe(Subscriber&lt;? super T&gt; subscriber) &#123; try &#123; subscriber.onStart(); RxJavaHooks.onObservableStart(this, onSubscribe).call(subscriber); return RxJavaHooks.onObservableReturn(subscriber); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); try &#123; subscriber.onError(RxJavaHooks.onObservableError(e)); &#125; catch (Throwable e2) &#123; Exceptions.throwIfFatal(e2); RuntimeException r = new OnErrorFailedException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2); RxJavaHooks.onObservableError(r); throw r; // NOPMD &#125; return Subscriptions.unsubscribed(); &#125;&#125; 有没有很眼熟？？可以返回上一篇文章里.subscribe()源码解析看一下，是的，你应该没有记错，这段代码跟.subscribe()的源码基本完全一样。核心的那句又出来了：1RxJavaHooks.onObservableStart(observable,observable.onSubscribe).call(subscriber); 也就是说，调用了ObservableA的onSubscribe里的call方法，也就是执行了ObservableA.subscribe(MapSubscriber)。而MapSubscriber其实是在OnSubscribeMap.call()中new出来的。可以理解成是属于B的。执行到这里B不再只是SubscriberC的被观察者了，他同时也是ObservableA的观察者，记为 SubscriberB。B = (ObservableB+SubscriberB)。 所以到这里，我们可以这样理解： 第一步：ObservableB.subscribe(SubscriberC)第二步：调用ObservableB的call方法第三步：在ObservableB的call方法里创建了SubscriberB ，并调用了ObservableA.subscribe(SubscriberB) 下一步跟之前以及RxJava基本调用逻辑一样，执行ObservableA的onSubscribe里的call方法。就是执行基本源码的这两句：ObservableA的onSubscribe12subscriber.onNext(&quot;hello rxjava&quot;);subscriber.onCompleted(); 也是根据上一章讲的RxJava基本调用（所以基本调用的逻辑很重要啊），这里事件开始下发了。下一步会执行ObservableA.subscribe(SubscriberB)中SubscriberB的onNext()和onCompleted()，也就是MapSubscriber。 MapSubscriber的源码在刚才的OnSubscribeMap里，它的onNext()里主要执行就下面两句：MapSubscriber的onNext()12result = mapper.call(t);actual.onNext(result); 这里mapper就是变换函数，通过MapSubscriber构造器向上找，发现就是OnSubscribeMap的 transformer，这个transformer也是OnSubscribeMap构造器传入的。再往上看，豁然开朗：就是map()里传的Func1，mapper.call也就是执行我们.map()里自己写的回调：mapper123456.map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.toUpperCase(); &#125;&#125;) 这里其实就是实现我们自己定义的变换了。我们定义的变换函数将String中的所有小写转换成了大写。下一步会执行actual.onNext(result)，这里就不再一层层的找了，这个actual其实就是o(即SubscriberC)。在SubscriberC的 onNext中我们输出了接收到的result，也就是变换过后的String。 同样在调用MapSubscriber.onCompleted()时会执行subscriberOne.onCompleted()。这样就完成了一整套的调用流程。 终于到最后总结了，想把转换说明白还是挺费劲的。前面没看懂的话可以看下下面总结出的调用逻辑（整合了基本调用的逻辑）： 第一步：创建ObservableA第二步：在调用.map()时创建ObservableB第三步：执行ObservableB.subscribe(SubscriberC)第四步：调用ObservableB的call方法第五步：在ObservableB的call方法里创建了SubscriberB，并调用了ObservableA.subscribe(SubscriberB)第六步：调用ObservableA里onSubscribe里的call，事件从A开始下发第七步：SubscriberB的onNext接收事件，并调用map()里的转换方法，事件继续下发第八步：SubscriberC的onNext接收转换后的事件。 至此，从被观察者A到观察者C的事件流就完成了。中间的转换可以简单理解成经历了一个B,B对A和C分别建立了观察和被观察的关系。在B中实现了事件流的转换。从A和C的一层订阅变成了ABC的两层订阅。 看下扔物线大神的这张图可能会更好理解我所说的两层订阅： 张磊大神的这张图则可以很清楚的理解调用逻辑： 4. 总结 到这里，map()转换原理就讲解完了，其实map()的原理本质是lift()。只不过map()这个操作符举例比较容易，逻辑也相对简单。有兴趣的工友可以看下扔物线大神的《给 Android 开发者的 RxJava 详解》里对lift()原理的解释，你会发现和map()实现是一样的。 下一章节，会基于这个变换原理，来讲解线程调度的源码分析，调用逻辑和map很相似。建议大家先把转换原理搞明白。大家加油！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（三）——RxJava的基本实现","slug":"一起读RxJava源码（三）——RxJava的基本实现","date":"2018-06-08T15:39:16.000Z","updated":"2018-10-11T15:37:36.224Z","comments":true,"path":"2018/06/08/一起读RxJava源码（三）——RxJava的基本实现/","link":"","permalink":"https://ten-z.github.io/2018/06/08/一起读RxJava源码（三）——RxJava的基本实现/","excerpt":"前两篇我们介绍了RxJava的一些基本概念，以及通过源码了解了观察者模式这一基础知识。从这一章开始，我们将依次由浅入深的了解RxJava的主要操作以及源码的实现。","text":"前两篇我们介绍了RxJava的一些基本概念，以及通过源码了解了观察者模式这一基础知识。从这一章开始，我们将依次由浅入深的了解RxJava的主要操作以及源码的实现。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度 1. 前言 在上一章节最开始我们提到过：RxJava的异步实现，是通过一种扩展的观察者模式来实现的。上一章节介绍了基础的观察者模式，这一章节我们一起来看一下RxJava是如何实现扩展的观察者模式的。 2. 扩展的观察者模式2.1 RxJava的四个基本概念Observable(可观察者，即被观察者)Observer/Subscriber(观察者)Subscribe(订阅)事件（相当于观察者模式中被观察者用来通知观察者的notifyObservers()方法，类似分发的事件） 2.2 工作原理 Observable和Observer/Subscriber通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer/Subscriber。 特别注意的是，与传统观察者模式不同，RxJava的Observer/Subscriber回调方法除了普通事件onNext()（相当于update）之外，还定义了两个特殊的事件：onCompleted()和onError()。 onCompleted()：事件队列完结。RxJava不仅把每个事件单独处理，还会把它们看做一个队列。RxJava规定，当不会再有新的onNext()发出时，需要触发onCompleted()方法作为标志。 onError()：事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中，onCompleted()和onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted()和onError()二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 RxJava的扩展的观察者模式大致如下图： 3. RxJava的基本实现使用RxJava的基本实现操作拢共分三步：第一步：初始化 Observable第二步：初始化 Observer第三步：建立订阅关系 基本调用完整起来是这样的： 请务必记住这个基本实现，在后面的源码讲解中还会回到这个基本实现代码上来。我会用“RxJava基本实现”加粗的方式表示需要回到这里看下面的基本实现代码，以便更好的理解源码。 RxJava基本实现1234567891011121314151617181920212223Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;垃圾软件，毁我青春&quot;); subscriber.onCompleted(); &#125;&#125;).subscribe(new Subscriber() &#123; @Override public void onCompleted() &#123; //System.out.println(&quot;onCompleted:&quot;); Log.d(&quot;tag&quot;, &quot;onCompleted:&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.d(&quot;tag&quot;, &quot;onNext:&quot; + ((String)o).toString()); &#125;&#125;); 和上一小节讲得工作原理一样，首先调用Observable.create()创建一个被观察者Observable，同时创建一个OnSubscribe作为create()方法的入参；接着创建一个观察者Subscriber，然后通过subseribe()实现二者的订阅关系。 下面就是对这三步进行源码的分析，看看他们都干了什么。 3.1 Observable.create()源码解析在上面的基本调用示例中，Observable.create()使用是这样的：Observable.create()源码解析1234567Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;垃圾软件，毁我青春&quot;); subscriber.onCompleted(); &#125;&#125;) 看下Observable.create()这个方法的源码Observable.create()源码123public static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) &#123; return new Observable&lt;T&gt;(RxJavaHooks.onCreate(f));&#125; 在执行Observable.create()的时候，直接返回了一个新创建的被观察者Observable。同时将RxJavaHooks.onCreate(f)作为构造函数的参数。进一步看一下Observable的构造函数：Observable构造函数123protected Observable(OnSubscribe&lt;T&gt; f) &#123; this.onSubscribe = f;&#125; 可以发现这里构造函数只是将传入的RxJavaHooks.onCreate(f)参数赋值给了Observable类里的onSubscribe引用，构造函数就结束了。我们从RxJava基本实现代码中看到RxJavaHooks.onCreate(f)里的f是Observable.create里那个新创建的onSubscribe。那么下一步看看传入的参数RxJavaHooks.onCreate(f)做了什么。RxJavaHooks.onCreate(f)源码1234567public static &lt;T&gt; Observable.OnSubscribe&lt;T&gt; onCreate(Observable.OnSubscribe&lt;T&gt; onSubscribe) &#123; Func1&lt;Observable.OnSubscribe, Observable.OnSubscribe&gt; f = onObservableCreate; if (f != null) &#123; return f.call(onSubscribe); &#125; return onSubscribe;&#125; 由于我们并没调用RxJavaHooks.initCreate()，所以上面代码中的onObservableCreate为null；于是代码会跳过if语句里的内容，继续执行下面的内容。因此RxJavaHooks.onCreate(f)最终返回的就是f，也就是我们在Observable.create()的时候new出来的OnSubscribe。 在这个基本的例子里，似乎RxJavaHooks.onCreate(f)有点多余，因为对传入的f直接返回了，还多了一层调用。不过，因为这个例子里我们的onObservableCreate为null，如果不为null，执行OnSubscribe的call回调(f.call)，其实是直接通知事件了，因为在OnSubscribe的call方法里一般会执行subscriber.onNext()，后面我们会看到类似的效果。 3.2 subscribe()源码解析 在示例代码RxJava基本实现中，执行完Observable.create()方法之后，返回了一个Observable，下一步会执行.subscribe()方法(Observable.subscribe())，相当于如下代码（这里的Observable是Observable.create()返回的）类比代码12345678910111213141516Observable.subscribe(new Subscriber() &#123; @Override public void onCompleted() &#123; Log.d(&quot;tag&quot;, &quot;onCompleted:&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.d(&quot;tag&quot;, &quot;onNext:&quot; + ((String)o).toString()); &#125;&#125;); 我们可以看到，在.subscribe()方法里传入个一个新创建的观察者Subscriber()。Subscriber()是实现Observer接口的一个抽象类，在初始化Subscriber()的时候实现了Observer接口的三个回调方法：onNext(),onCompleted(),onError()。 下面来看下.subscribe()里做了些什么。.subscribe()源码解析12345678910111213141516171819202122232425public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) &#123; return Observable.subscribe(subscriber, this);&#125;static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) &#123; …… // new Subscriber so onStart it subscriber.onStart(); if (!(subscriber instanceof SafeSubscriber)) &#123; subscriber = new SafeSubscriber&lt;T&gt;(subscriber); &#125; try &#123; // allow the hook to intercept and/or decorate RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber); return RxJavaHooks.onObservableReturn(subscriber); &#125; catch (Throwable e) &#123; …… &#125; return Subscriptions.unsubscribed(); &#125;&#125; 看上去有点唬人，我里删减了下。最核心的其实是这句1RxJavaHooks.onObservableStart(observable,observable.onSubscribe).call(subscriber); 这里RxJavaHooks和之前提到的一样，返回的是第二个入参observable.onSubscribe，也就是RxJava基本实现中observable.create()里初始化的onSubscribe。 所以这段代码可以看成：1onSubscribe.call(subscriber) 这里可以看到，onSubscribe里的call被调用了，这意味着事件发送的逻辑开始运行。因此在RxJava中，Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候。 我们继续看onSubscribe.call(subscriber)的执行情况。在RxJava基本实现中onSubscribe在它的call方法实现里执行了如下两行代码：onSubscribe的call回调12subscriber.onNext(&quot;垃圾软件，毁我青春&quot;);subscriber.onCompleted(); 于是，接下来会将参数传给subscribe()方法里Subscriber对象的onNext()，onNext()接收参数并输出日志。然后执行subscriber的onCompleted()，原理同上。 最后，RxJava基本实现就完成了，结果如下图： 4. 总结 简单总结一下RxJava基本实现的调用逻辑： 初始化被观察者Observable 初始化观察者Subscriber 通过subscribe()建立订阅关系，并立即发送事件 执行onSubscribe里的call回调，发送事件 观察者Subscriber的相应回调接收事件参数，执行各自逻辑 至此，我们把RxJava的基本实现顺着源码的逻辑捋了一篇，这里用张磊大神的一张图来说明具体调用的逻辑： 我们发现RxJava首先是实现了一个订阅的形式，将观察者和被观察者解耦，这里和普通观察者还是很像的。同时，我们也发现Rxjava一但执行了订阅方法subscribe()就会立刻发送事件，它没有像普通观察者内部Vector的存储机制，也就无法解决一对多依赖的问题。 下一章节，我们会一起学习RxJava基本操作符–主要是变换操作符的一些源码和逻辑。在此之前，建议先把基础的逻辑看懂。加油！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（二）——基础知识:观察者模式","slug":"一起读RxJava源码（二）——基础知识-观察者模式","date":"2018-05-27T11:49:06.000Z","updated":"2018-10-11T15:37:24.600Z","comments":true,"path":"2018/05/27/一起读RxJava源码（二）——基础知识-观察者模式/","link":"","permalink":"https://ten-z.github.io/2018/05/27/一起读RxJava源码（二）——基础知识-观察者模式/","excerpt":"不知不觉博客搭建完成已经一个多月了，至今磕磕绊绊才发了两篇。搭建自己的博客之前看过不少别人搭建的技术博客，隐约发现一个有意思的规律，似乎每个博客里总有几篇文章的配图会出现女明星-尤其是日本女明星的图片。我看过的绝大多数技术博客都完美的符合这一规律，原因不详，不明觉厉。平常倒是见过很多餐厅里挂关公、宿舍里挂科比柯南的，不知道是不是同一个道理，emmm……そですね。 所以写这一篇博客的时候觉得也遵守一下规律，求以后写博客文思泉涌，周末不加班……。","text":"不知不觉博客搭建完成已经一个多月了，至今磕磕绊绊才发了两篇。搭建自己的博客之前看过不少别人搭建的技术博客，隐约发现一个有意思的规律，似乎每个博客里总有几篇文章的配图会出现女明星-尤其是日本女明星的图片。我看过的绝大多数技术博客都完美的符合这一规律，原因不详，不明觉厉。平常倒是见过很多餐厅里挂关公、宿舍里挂科比柯南的，不知道是不是同一个道理，emmm……そですね。 所以写这一篇博客的时候觉得也遵守一下规律，求以后写博客文思泉涌，周末不加班……。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度 1. 前言 上一篇对RxJava做了个简单介绍，在一起读源码前还有一些基础知识要啰嗦两句，个人认为对理解RxJava源码思想有很大的帮助。 2. 观察者模式 RxJava的异步实现，是通过一种扩展的观察者模式来实现的。在之前，当然首先要理解观察者模式。 2.1 观察者模式定义观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 ——《head first 设计模式》 简单举个例子：我们看看报纸和杂志的订阅是怎么回事： 1、 报社的业务就是出版报纸。2、 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。3、 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。4、 只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。 简单一句话概括就是：出版者+订阅者=观察者模式 报社和订阅者组成的模式其实就是观察者模式。翻译成普通话就是：主题(Subject)/被观察者(Observable) + 观察者(Observer) = 观察者模式。 2.2 观察者模式作用重要作用：解耦。也就是将观察者和被观察者解耦。并且解决一对多依赖的问题。 2.3 观察者模式UML类图 2.4 java内置观察者模式源码解析 Java API提供了内置的观察者模式。Java.util包里包含最基本的Observer接口以及Observable类。下面我们来具体看一下他们的源码。 首先是java.util.Observable，这是一个被观察者的类，相当于出版者/社。这里只节选了主要方法和逻辑并进行了注释，方便理解原理。多说一句，其实类里的英文注释讲的非常清楚了，但是由于和中文注释混在一起实在太乱，于是这里把英文的删掉了。英文好的工友可以直接看类里的英文注释。java.util.Observable源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; public Observable() &#123; obs = new Vector&lt;&gt;(); //这里初始化一个存放观察者“们”（Observers）的容器。可以理解为报社里存储订阅者地址的清单。它是线程安全的。 &#125; /** * 这个方法是添加观察者的方法，被addObserver添加进来的不重复的Observer（观察者）放到Vector容器里，这个Observer（观察者）就和当前被观察者产生了依赖。 * 还是用订报纸的模型解释，就是订阅者订报的过程---订阅者把自己的地址发给报社，报社在确认送报清单里这是个新客户之后，把新客户地址加到地址清单里。 */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * 将观察者从被观察者的Vector容器里删除。取消此观察者和被观察者的依赖。 * 订报模型解释—-订阅者通知报社取消订报，报社把该订阅者的地址从地址清单里取消。以后送报就不会送到此订阅者了。 * / public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; /** * 下面两个方法是当被观察者状态变化时调用，主要通过for循环依次调用Vector容器存储的Observer（观察者）的update方法，从而通知并更新全部有依赖的观察者。 * 订报模型解释—-新的报纸出版了（状态变化），按照清单地址依次给每个订阅者送报。 */ public void notifyObservers() &#123; notifyObservers(null); &#125; public void notifyObservers(Object arg) &#123; Object[] arrLocal; synchronized (this) &#123; // if (!changed) if (!hasChanged()) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; /** * 被观察者清空所有有依赖的观察者。 * 订报模型解释——报社拖欠工资，送报员把清单烧了。 */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * 标记被观察者状态已经改变的事实。在notifyObservers之前调用，可以看notifyObservers代码中changed为false时不会执行for循环通知观察者的方法。 */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * 将change状态设置成false，通知观察者方法失效。 */ protected synchronized void clearChanged() &#123; changed = false; &#125; public synchronized boolean hasChanged() &#123; return changed; &#125; /** * 返回已添加进Vector容器的观察者的数量。 * 订报模型解释—当前订报人数。 */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 再来看下java.util.Observer，实现观察者的接口。就是订阅者。java.util.Observer源码解析123public interface Observer &#123; void update(Observable o, Object arg);&#125; 是的，观察者接口就只有这么简单的一个方法，update(Observable o, Object arg)：第一个参数（Observable o）被观察者（主题）本身当做第一个变量，好让观察者知道是哪个被观察者（主题）通知它的；第二个参数（Object arg）传入notifyObservers()的数据对象，如果没有说明则为null。 可以看到，Java里通过Observer接口以及Observable类实现了最基本的观察者模式。通过源码解析我们也可以发现它的实现原理还是非常的简单的，其实是通过维护一个内部数组集合加上接口的回调，却很好的解决了观察者和被观察者解耦的问题。同时，Observable对各方法都加了synchronized关键字(notifyObservers的在方法内)，也就是说，Observable是线程安全的，每次调用方法前都需要取得Observable对象的锁。 3. 总结 在最开始的时候，我们抛出了个概念：“RxJava的异步实现，是通过一种扩展的观察者模式来实现的。”因此这一章节首先带大家回顾了一个基础知识就是常规的观察者模式。我们可以看到，观察者模式是解决对象之间的一对多的依赖问题，而对于RxJava而言，扩展的观察者模式主要解决的是异步实现的问题。这也是我总结出的扩展的观察者模式和常规观察者模式的区别之一。在下一章节会和大家一起学习RxJava的扩展的观察者模式是如何实现的。大家加油。","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（一）——简介","slug":"一起读RxJava源码（一）——简介","date":"2018-05-12T07:06:21.000Z","updated":"2018-10-11T15:37:08.344Z","comments":true,"path":"2018/05/12/一起读RxJava源码（一）——简介/","link":"","permalink":"https://ten-z.github.io/2018/05/12/一起读RxJava源码（一）——简介/","excerpt":"RxJava已经火了一段时间了，我的项目包括我最近看的很多项目都在用RxJava。之前学习了一些RxJava原理及源码，有了一些感悟，在此做一个系列进行总结。 学无止境，大家加油！","text":"RxJava已经火了一段时间了，我的项目包括我最近看的很多项目都在用RxJava。之前学习了一些RxJava原理及源码，有了一些感悟，在此做一个系列进行总结。 学无止境，大家加油！ 版权声明：本文为博主原创文章，未经博主允许不得转载。 读前注意事项：1.本篇文章创作时间为2017.5.2，由于之前没有个人博客，所以现在才发出来。在发出之前做了些许修改。2.本编文章基于RxJava 1.x。3.由于本人是个Android搬砖工，因此本文仅限于Android上对RxJava的理解和运用，其他类型的工友能看懂主要思想和逻辑即可。4.推荐几篇文章： 最权威：ReactiveX官网官方文档http://reactivex.io/ RxJava 1.x:朱凯（扔物线）《给 Android 开发者的 RxJava 详解》 http://gank.io/post/560e15be2dca930e00da1083#toc_18张磊BARON RxJava系列1~7 https://www.jianshu.com/p/ec9849f2e510 RxJava 2.x:南尘 这可能是最好的RxJava 2.x 教程 https://www.jianshu.com/p/0cd258eecf60 5.本系列文章主要侧重于RxJava基本原理和基本实现的源码解析，对RxJava各种操作符的各种用法可能不会介绍得很全，算是一篇RxJava源码解读入门级的文章。 RxJava其他各种炫酷的用法可以去拜读上面几位大神的文章，写的都很详细。如果还想更深入学习推荐阅读官方文档。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度 1. 前言 RxJava应该是从大概15年开始(？大概吧)，被越来越多的开发者关注并学习。至今已然成为很多公司和个人项目的首选，尤其是没有自己网络封装库的公司的首选(emmm…)。比较著名的就是各种博客论坛公众号都在介绍的RxJava+Retrofit+mvp。 虽然目前RxJava 2.x已经出了一段时间了，官方也已经终止对RxJava 1.x的维护。但是我还是没有远见的写了一篇关于RxJava 1.x的文章。主要是因为在自己看源码的那个时间段里RxJava 1.x的文章最多，而RxJava 2.x的文章没有找到通俗易懂适合初学者的。因此本着初学源码，理解为上的原则，还是选择学习RxJava 1.x的源码来学习。当然，不出意外的，首先主要看了最经典的装X必读：朱凯（扔物线）写的《给 Android 开发者的 RxJava 详解》。看了N遍之后，得出了下面的结论: 后来又拜读了张磊大神写的RxJava系列1~7，在掉了几万根秀发以后终于摸到了一些门道——大概就是我的头型还不够圆……以及RxJava源码的一些理解。于是写下了这篇文章，跟着学渣装X慢慢看懂RxJava。 2. RxJava相关概念2.1 先忽略Java，来看下Rx RX，全称是ReactiveX，官网链接在上面的推荐文章里。官网上的第一句话就明确的写出了它的作用：An API for asynchronous programming with observable streams 大概翻译：一种异步编程API，使用（with介词，我觉得翻译成使用比较好）可观察流 Rx的官方定义 这个定义有点抽象，但是也告诉了我们三个事情。1、这是一个API2、这是一个用来实现异步编程功能的API3、实现这个功能使用的是可观察流的方式 下面再来看官网的第二句话和图： The Observer pattern done rightReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming 大概翻译：观察者模式的正确使用ReactiveX是从观察者模式、迭代器模式和函数式编程的最佳思想的组合。 Rx定义的官方解释 所以，上面的可观察流可以理解为是一种观察者模式、迭代器模式和函数式编程的组合。当然起主要作用的我认为是观察者模式，毕竟done right。 再来看官网的最下面一句话：ReactiveX is more than an API, it’s an idea and a breakthrough in programming. It has inspired several other APIs, frameworks, and even programming languages. 大概翻译：ReactiveX不仅仅是一个API，它是编程的一个思想和突破。它启发了其他几个API、框架，甚至是编程语言。 Rx的意义 瞬间高大上了有木有，把ReactiveX升华成了一种思想。思想能干什么？思想能改变世界啊……扯远了，所以这么牛X的框架，就问你： 那我们开始吧。 2.2 所以RxJava是什么 刚刚介绍了Rx，后面加上Java当然就是使用Java语言来编写和使用的Rx。官网上还有其他语言的Rx。比如：RxJS、Rx.NET、RxScala、RxSwift……。本系列的所有文章都是基于RxJava来讲解的。 对于Rxjava是什么。大神们给的一个词是“异步”。“RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.” 大概翻译：RxJava 是Reactive Extensions在 Java VM 上的实现， 是一个用可观测序列(基于观察者模式)来组成异步的、基于事件的程序的库。注：Reactive Extensions：An API for asynchronous programming with observable streams。（Reactive Extensions是用可观测流实现异步编程的API，有基于各种语言的库。RxJava是其中一种。） “It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.”大概翻译：它扩展了观察者模式以支持数据/事件序列，并添加了操作符允许您声明性地将序列组合在一起，同时抽象出对诸如低级线程、同步、线程安全和并发数据结构等。 RxJava在GitHub主页上的自我介绍 简单理解：异步操作库。这个库基于异步可以实现诸多功能，其中最火的莫过于响应式编程，在后面的章节里会稍微介绍一下响应式编程相关基础。 3. RxJava好在哪 好在哪主要是得和别的类库比较。Android一般是和本平台上已经为开发者提供的AsyncTask,Handler等用来做异步操作的类库比较。比较的结果就是：简洁。随着程序逻辑变得越来越复杂，它依然能够保持简洁。 注：以下例子均取自大神朱凯（扔物线）的《给 Android 开发者的 RxJava 详解》一文（不包含表情包），例子确实很通俗易懂，所以本人就不胡编乱造了。直接看。 假设有这样一个需求：界面上有一个自定义的视图imageCollectorView，它的作用是显示多张图片，并能使用addImage(Bitmap)方法来任意增加显示的图片。现在需要程序将一个给出的目录数组File[] folders中每个目录下的 png 图片都加载出来并显示在imageCollectorView中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在UI线程执行。常用的实现方式有多种，这里贴出其中一种： 通过Thread新建线程读取图片，并通过runOnUiThread更新imageCollectorView1234567891011121314151617181920new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(&quot;.png&quot;)) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的：RxJava实现123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(&quot;.png&quot;); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 这里代码看上去行数是变多了，但是逻辑却变得简洁了，用有文化（装X）一点的词形容叫“对仗”。RxJava 实现的是一条从上到下的链式调用，没有任何嵌套。 配合Lambda表达式使用效果拔群：RxJava+Lambda1234567Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(&quot;.png&quot;) &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。 4. 总结 Rxjava简介到这就差不多了，相信大家都了解了Rx的作用和功能，也能感受到RxJava的优势——简洁。在进入正题之前，还有一些基础要熟悉一下。下一篇文章会对基础之一的观察者模式做一个介绍，敬请关注！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"Android基于Jenkins+Git+Gradle+七牛云+QR-Code实现自动打包、上传七牛云并生成二维码","slug":"Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码","date":"2018-04-21T14:18:41.000Z","updated":"2018-08-26T07:01:43.421Z","comments":true,"path":"2018/04/21/Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码/","link":"","permalink":"https://ten-z.github.io/2018/04/21/Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码/","excerpt":"题目很长，本篇文章内容也如题目所示，介绍工作中借助自动化手段，提高团队间工作效率的一种很好的方法。","text":"题目很长，本篇文章内容也如题目所示，介绍工作中借助自动化手段，提高团队间工作效率的一种很好的方法。 版权声明：本文为博主原创文章，未经博主允许不得转载。 对于移动端的开发和测试，一般流程是测试人员向移动端开发人员要测试包，开发通过本地IDE（Android开发一般是Android Studio）打好包后通过各种媒介传给测试人员。测试人员拿到包后开始测试，一但发现bug，会通知开发人员修改，然后再重复上面的过程。 为了简化工作流程，提高效率，可以选择jenkins做持续集成。将jenkins部署在服务器上，通过jenkins实现app自动化打包。这样一来，开发人员每次只需将代码提交到版本控制系统（如git）的远程代码库上，测试人员可以根据自己需求和时间使用jenkins进行自动打包。实现开发与测试的“解耦合”。 网上关于Android开发Jenkins部署的文档有很多，不过绝大部分文档都是上传蒲公英等网站，这些网站能自动生成下载二位码并返回，可以减少部署难度，网上可参考的资料也更多，推荐优先选择这些网站。但是如果你在的公司并没有用蒲公英（比如我目前的公司），而是用的七牛云等没有返回二维码只是可以生成下载链接的网站，那么这篇文章或许能够帮到你更多。 ♨ 综上所述，没钱就要多努力，人丑就要多读书。 特别提示，下面的内容可能图比字多，因为配置这种东西我认为还是图更能说明问题。 1. Jenkins部署 这部分网上资料太多了，本人也是按照网上的教程一步一步配的。这里就不一一复制粘贴写了。可以自行百度，也有几个推荐的网址： http://blog.csdn.net/u011541946/article/details/78267097 http://www.jianshu.com/p/38b2e17ced73 http://blog.csdn.net/mabeijianxi/article/details/52680283 http://blog.csdn.net/fengshi_sh/article/details/50669754 http://www.jianshu.com/p/915c1ae69144 1.1 推荐安装插件 Branch API Plugin build timeout plugin build-name-setter Credentials Binding Plugin description setter plugin Dynamic Parameter Plug-in Environment Injector Plugin fir-plugin（可选） Git plugin（可选） GIT server Plugin(可选) Gradle Plugin Pipeline: Basic Steps Pipeline: Build Step Pipeline: Input Step Pipeline: Nodes and Processes Pipeline: Stage Step Post-Build Script Plug-in SSH Slaves plugin Subversion Release Manager plugin(可选) Timestamper Workspace Cleanup Plugin Subversion Plug-in(可选) （不一定都能用上，反正我是能装的都装了） 2. JDK、androidSDK、androidNDK等配置回到主界面-&gt;系统管理-&gt;全局属性： 配置好JDK（NDK）与PYTHON。注意：1. 相关配置需要Overall权限，在 系统管理-ConfigureGlobal Security 里配置账户权限。2. 这里的键需要和服务器环境变量内的Android SDK/NDK目录的键一致。 2.1 安装Gradle点击系统管理-Global tool configuration gradle可以直接用服务器的安装地址（如果服务器已安装），也可以选择自动安装，自动安装jenkins在第一次打包的时候回会自动下载，因此第一次打包时间会很长。 ♨ 这里有个小问题，如果gradle勾选自动安装，勾选框的上面name这个输入框尽量以后不要改动，亲自入坑测试发现仅仅改动name后，下一次打包时会从新下载gradle（原因是自动安装的目录名就是配置的的name，改动name相当于改了安装路径，gradle会在新的安装路径下重新下载安装）。 3. 创建项目并打包前面主要是在配置环境，环境搭好下面就可以配置项目了。 3.1 创建项目回到主界面-&gt;新建-&gt;构建一个自由风格的项目-&gt;ok: 3.2 git配置进入到刚创建的项目中点击“配置”，找到“源码管理”，选择“Git”。 3.3 构建–Invoke Gradle script Gradle Version:选择系统管理里配置的gradle-nameTasks:填gradle构建命令：clean是打包之前清除一下上一次编译记录。assembleRelease 或者assembleDebug，对应AS里release和debug版的包其他请自行百度gradle构建命令Pass job parameters as Gradle properties:如果需要参数化构建，需要勾选。参数化构建内容在下面一节。 3.4 参数化构建 参数化构建的主要功能是将jenkins里配置的参数注入到Android项目中的配置里，而勾选Pass job parameters as Gradle properties这个选择框可以帮我们侵入到gradle.properties文件中替换相同名称变量的值。达到入侵的效果。 由于build.gradle文件能够直接引用gradle.properties文件中的属性，因此入侵的参数如果要在build.gradle中使用的话可以直接调用。然而我们有些入侵的参数需要在java代码里用到，这就需要用到defaultConfig里面的buildConfigField方法。 上面一大波操作可能有点令人窒息，上干货： 3.4.1 先是参数配置勾选参数化构建流程，选择添加参数: 可选的参数类型有很多，这里只介绍Choice Parameter和Dynamic Parameter。其他参数类型可自行尝试。 Choice Parameter：是单选参数，配置时列出所有参数，用换行隔开，如下图： 配置完成后点击保存，回到项目页面，点击Build with Paramters，可看到刚刚配置的单选效果。开始构建后，所选择的值就会被注入到gradle.properties文件中替换相同名称变量的值。如下图： Dynamic Parameter：这个参数的值会根据你添加的Groovy脚本自动生成。配置方式如图： 其他的参数以及使用方法请自行查阅。 3.4.2 jenkins入侵参数的调用 我们知道参数化构建是将jenkins配置的参数侵入到gradle.properties文件中替换相同名称变量的值。因此，第一步就是要在Android项目下的gradle.properties文件中写入相同名称和初始值。 构建成功后，这里的EXAMPLE的值就会被jenkins上配置的EXAMPLE多选框选中的值替换。因此在程序中可以像使用gradle.properties中的参数一样使用入侵的参数。 build.gradle中调用gradle.properties的参数：build.gradle中可以直接可以调用gradle.properties中被jenkins修改过值的参数。这里以SDK_VERSION相关参数为例，如下图：gradle.properties:build.gradle: java代码中调用gradle.properties的参数：Java代码中调用gradle.properties文件里的参数需要build.gradle文件做一个桥梁，具体就是在build.gradle文件里调用buildConfigField方法。如下图： 这里的buildConfigField就是自定义一个常量，第一个参数表示类型，第二参数表示常量名，第三个参数传入的是值。这里${EXAMPLE}就是传入的gradle.properties里EXAMPLE变量的值。通过这个方法Gradle就会在BuildConfig这个类中加入常量API_HOST，如下图： 通过jenkins构建之后BuildConfig类里的的API_HOST的值就会被jenkins中配置的EXAMPLE的值替换。 下一步，在java代码里中调用BuildConfig.API_HOST，取到jenkins配置的变量的值：1public static String LOGIN_URL = BuildConfig.API_HOST 参数注入在实际工作中还是有很多用途的，比如可以用来配置不同环境、修改某些参数等等。 4. 七牛上传4.1 编译并安装七牛插件qiniu-plugin 经过上面几步出神入化的微操之后，我们已经可以在jenkins服务器上进行打包了，下面就是要将打好的apk上传到七牛云上，方便各位大佬下载（管开发要安装包的都是大佬，反正我是这么认为的）。 将apk上传七牛云有几种方法，Python好的同学可以自行研究下命令行上传。这里介绍一种老少皆宜的方法：使用七牛插件上传。但是，目前在七牛开发者中心-Jenkins七牛插件中已经找不到相关插件了，不过在万能的github上还可以找到源代码：https://github.com/ipy/qiniu-plugin 推荐一个网址可以参考：http://blog.csdn.net/fengshi_sh/article/details/50669754但是该网址里面的很多代码有误，这里亲测并修改了： 下载好源码后，建议修改QiniuPublisher.java文件 1 注释掉System.console().printf(profile.getName() + &quot;/n&quot;) 2 在第107行 123//String keyPath = path.getRemote().replace(wsPath, \"\");//String key = keyPath.replace(File.separator, \"/\");String key = path.getName(); 3 由于java8环境，还要修改pom.xml文件 12345678910111213diff --git a/pom.xml b/pom.xmlindex 0f577be..4d7c73d 100644--- a/pom.xml+++ b/pom.xml@@ -13,7 +13,7 @@ &lt;parent&gt; &lt;groupId&gt;org.jenkins-ci.plugins&lt;/groupId&gt; &lt;artifactId&gt;plugin&lt;/artifactId&gt;- &lt;version&gt;1.509.4&lt;/version&gt;+ &lt;version&gt;1.554.1&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;org.6wind.jenkins&lt;/groupId&gt; 修改完成后，就可以编译了，步骤如下： 在”终端”里执行1234567brew install maven cd /Users/apple/Downloads/qiniu-plugin-master //进入源码文件夹 export MAVEN_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n&quot; mvn hpi:run //会运行起一个模拟环境^q //退出该模拟环境，mvn clean //删除target，第一次无需执行这个 mvn package //打包生成Tagret，新生成的.hpi文件就在target下 最后，将编译好的.hpi导入jenkins插件: 系统管理–管理插件–高级–上传插件然后在增加操作后步骤选项框里就能看到上传到七牛的选项了！ 4.2 七牛设置项（系统管理–系统设置） Accesskey/Secretkey 值可在七牛账户中查看，对应AK和SK 4.3 配置上传到七牛的相关参数增加构建后造作步骤—&gt;上传到七牛 选择上传到七牛后显示如下： 需填写的内容：七牛配置项：系统设置-七牛-设置项名称文件路径：需要上传的文件路径要上传到的 bucket：上传到七牛的空间（文件夹）名称勾选“构建失败则不上传” 上传成功后，七牛官方给出的反馈日志如图 构建后在jenkins构建项目的Console Output里能看到相关日志，证明上传成功。 5 生成七牛下载链接和二维码最终效果如下图，构建完成后会显示在项目主页的构建历史里。 5.1 生成七牛下载链接 由于请求七牛的返回值里没有具体链接，只有目标资源的最终名字。而七牛的bucket文件夹一旦创建，这个bucket的外链默认域名是固定的，因此七牛的链接需要手动把bucket下载链接拼上。（目前七牛bucket文件夹生成的临时域名需要绑定自定义域名，但是在这里并不影响我们的配置，配置了的话换成自定义域名就好。） 链接的展示需要用到：构建后操作—Set build description在这个插件里写好的链接会出现在此项目主页的构建历史里。 使用这个插件之前，需要到系统配置—安全配置中，将MarkUp Formatter修改为Safe HTML，这样展现的二维码和链接才能显示成H5标签，否则会显示成文本。 接下来配置Set build description。 第一行是正则表达式，这里的”key”:”(.*)”是用来匹配七牛返回链接里的”key”:””的值。 第二行是显示的h5代码，这里是生成了能点击的链接，\\1表示引用上面正则里的第一个值。 构建成功后生成这样的下载链接: 5.2 生成下载链接的二维码 由于七牛并不像蒲公英等网站能自动生成二维码，因此需要自己手动去生成。 在gradle版本升级到了4.1以上的时候，由于每次生成文件目录是一样的，而gradle又执行了clean命令，因此每次执行打包命令时output下的目录都会被清理（但是可以节省空间），因此用本地apk的路径生成二维码不太合适。这里选择将七牛的下载链接生成二维码，保证可控时间内链接都有效，而且可以外网访问。 按照正常逻辑来讲，应该是先上传七牛之后再生成七牛下载链接的二维码，毕竟没有上传的时候下载链接应该是不存在的。但是，由于生成二维码需要用到Execute shell这个插件，而这个插件在jenkins中是在“构建”这个模块下配置的，而七牛上传插件是在“构建后操作”这个模块下配置的。如图所示： 也就是说，在上传七牛以前就要生成下载链接二维码！！！ 是的，就是这种令人窒息的操作。方法其实很简单，这里还是用了那个小技巧：七牛的bucket(文件夹)一旦创建，这个bucket的外链默认域名是固定的。 也就是说，七牛的下载链接在上传七牛以前我们就能自己拼好(上传的文件名是自己定义的)，二维码因而也可以在上传之前生成。 下面是具体配置： 需要用到python和qrcode这个库。 第一步：下载安装Python和pipwindows和Ubuntu安装方式有点区别，请自行百度。 命令行输入：pip list 检查是否安装成功 第二步：安装Pillow由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 命令行输入：pip install Pillow 第三步：安装qrcode 命令行输入：pip install myqr 第四步：Jenlins中配置Python环境变量 进入 →系统管理 →系统设置 找到 Enviroment variables 第五步：生成二维码指令进入项目→构建→增加构建步骤，选择Execute shell（Ubuntu），或者Execute windows batch command（windows）,填写qrcode生成二维码的python命令： 格式如下：myqr apk下载链接 -n 二维码命名 -v 1 -l L -d 二维码存储路径具体指令含义详见: https://github.com/sylnsfar/qrcode 第六步：展示二维码 构建后操作 → 增加构建后操作步骤→Set build description在原有七牛下载链接上添加刚才二维码保存的图片路径： 最后点击保存。 在项目页面点击 大功告成！！！！","categories":[{"name":"自动化","slug":"自动化","permalink":"https://ten-z.github.io/categories/自动化/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://ten-z.github.io/tags/Jenkins/"}]}]}