{"meta":{"title":"TEN-Z'S BLOG","subtitle":null,"description":"Thank you for reading my story","author":"ten-z","url":"https://ten-z.github.io"},"pages":[{"title":"关于我","date":"2018-03-18T06:11:26.000Z","updated":"2018-08-13T13:15:12.606Z","comments":false,"path":"about/index.html","permalink":"https://ten-z.github.io/about/index.html","excerpt":"","text":"The future is in your hands now. 随便写写♨ 说实话目的性不是很强，毕竟不是大神级的专业博主，主要是最近学习或者碰到问题的整理记录。♨ 文笔略强于小学生作文，如果觉得文字读不懂的……可以翻译成英文再试试。♨ 内容上以自己理解为主，强烈反对对别人文章全篇的复制粘贴（这种现象在国内博客网站上还是挺严重的）。少部分文字和图片会借鉴别人，但主要阐述自己理解。如果有不对的地方，欢迎批评指正。 请多关照♨ 4年有余Android开发♨ 个人认为基础很重要，尤其是算法、数据结构和设计模式，是非常有助于深层次的学习的（尤其是看源码：RTFSC – Read The Fucking Source Code）。♨ 通信专业毕业，还有很多计算机专业基础等着要学。♨ 会一点H5(JS)、会一点Python、但目前主要的还是把Android和Java学好，当然，还有Kotlin。♨ 以后还需要学的东西可能会更多，看谷歌还能整出什么新玩意吧。 联系方式♨ Email: t_john@126.com♨ Github: https://github.com/ten-z♨ Blog: https://ten-z.github.io/ 膜拜大神这里是个人觉得对于学习很有帮助的大神的博客链接，当然主要是Android和Java的。♨ 郭霖的专栏：https://blog.csdn.net/guolin_blog/♨ Hongyang：https://blog.csdn.net/lmj623565791/♨ 胡凯：http://hukai.me/♨ HenCoder（扔物线）：http://hencoder.com/♨ 技术小黑屋：https://droidyue.com/♨ 刘望舒的博客: http://liuwangshu.cn/"},{"title":"categories","date":"2018-03-18T06:11:19.000Z","updated":"2018-04-25T15:25:40.015Z","comments":false,"path":"categories/index.html","permalink":"https://ten-z.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-18T06:11:02.000Z","updated":"2018-04-25T15:24:57.507Z","comments":false,"path":"tags/index.html","permalink":"https://ten-z.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一起读RxJava源码（一）——简介","slug":"一起读RxJava源码（一）——简介","date":"2018-05-12T07:06:21.000Z","updated":"2018-09-16T11:04:05.893Z","comments":true,"path":"2018/05/12/一起读RxJava源码（一）——简介/","link":"","permalink":"https://ten-z.github.io/2018/05/12/一起读RxJava源码（一）——简介/","excerpt":"RxJava已经火了一段时间了，我的项目包括我最近看的很多项目都在用RxJava。之前学习了一些RxJava原理及源码，有了一些感悟，在此做一个系列进行总结。 学无止境，大家加油！","text":"RxJava已经火了一段时间了，我的项目包括我最近看的很多项目都在用RxJava。之前学习了一些RxJava原理及源码，有了一些感悟，在此做一个系列进行总结。 学无止境，大家加油！ 版权声明：本文为博主原创文章，未经博主允许不得转载。 读前注意事项：1.本篇文章创作时间为2017.5.2，由于之前没有个人博客，所以现在才发出来。在发出之前做了些许修改。2.本编文章基于RxJava 1.x。3.由于本人是个Android搬砖工，因此本文仅限于Android上对RxJava的理解和运用，其他类型的工友能看懂主要思想和逻辑即可。4.推荐三篇大神的文章： RxJava 1.x:朱凯（扔物线）《给 Android 开发者的 RxJava 详解》 http://gank.io/post/560e15be2dca930e00da1083#toc_18张磊BARON RxJava系列1~7 https://www.jianshu.com/p/ec9849f2e510 RxJava 2.x:南尘 这可能是最好的RxJava 2.x 教程 https://www.jianshu.com/p/0cd258eecf60 5.本系列文章主要侧重于RxJava基本原理和基本实现的源码解析，对RxJava各种操作符的各种用法可能不会介绍得很全，算是一篇RxJava源码解读入门级的文章。 RxJava其他各种炫酷的用法可以去拜读上面几位大神的文章，写的都很详细。 1. 前言 RxJava应该是从大概15年开始(？大概吧)，被越来越多的开发者关注并学习。至今已然成为很多公司和个人项目的首选，尤其是没有自己网络封装库的公司的首选(emmm…)。比较著名的就是各种博客论坛公众号都在介绍的RxJava+Retrofit+mvp。 虽然目前RxJava 2.x已经出了一段时间了，官方也已经终止对RxJava 1.x的维护。但是我还是没有远见的写了一篇关于RxJava 1.x的文章。主要是因为在自己看源码的那个时间段里RxJava 1.x的文章最多，而RxJava 2.x的文章没有找到通俗易懂适合初学者的。因此本着初学源码，理解为上的原则，还是选择学习RxJava 1.x的源码来学习。当然，不出意外的，首先主要看了最经典的装X必读：朱凯（扔物线）写的《给 Android 开发者的 RxJava 详解》。看了N遍之后，只感觉大神文章文采斐然、逻辑精妙……却没有一丝看懂的意思。 后来又拜读了张磊大神写的RxJava系列1~7，在掉了几万根秀发以后终于摸到了一些门道——大概就是我的头型还不够圆……以及RxJava源码的一些理解。于是写下了这篇文章，跟着学渣装X慢慢看懂RxJava。 2. RxJava是什么 大神们给的一个词是“异步”。“RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.” 大概翻译：RxJava 是Reactive Extensions在 Java VM 上的实现， 是一个用可观测序列(基于观察者模式)来组成异步的、基于事件的程序的库。注：Reactive Extensions：An API for asynchronous programming with observable streams。（Reactive Extensions是用可观测流实现异步编程的API，有基于各种语言的库。RxJava是其中一种。） “It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.”大概翻译：它扩展了观察者模式以支持数据/事件序列，并添加了操作符允许您声明性地将序列组合在一起，同时抽象出对诸如低级线程、同步、线程安全和并发数据结构等。 RxJava在GitHub主页上的自我介绍 简单理解：异步操作库。这个库基于异步可以实现诸多功能，其中最火的莫过于响应式编程，在后面的章节里会稍微介绍一下响应式编程相关基础。 3. RxJava好在哪 好在哪主要是得和别的类库比较。Android一般是和本平台上已经为开发者提供的AsyncTask,Handler等用来做异步操作的类库比较。比较的结果就是：简洁。随着程序逻辑变得越来越复杂，它依然能够保持简洁。 注：以下例子均取自大神朱凯（扔物线）的《给 Android 开发者的 RxJava 详解》一文（不包含表情包），例子确实很通俗易懂，所以本人就不胡编乱造了。直接看。 假设有这样一个需求：界面上有一个自定义的视图imageCollectorView，它的作用是显示多张图片，并能使用addImage(Bitmap)方法来任意增加显示的图片。现在需要程序将一个给出的目录数组File[] folders中每个目录下的 png 图片都加载出来并显示在imageCollectorView中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在UI线程执行。常用的实现方式有多种，这里贴出其中一种： 通过Thread新建线程读取图片，并通过runOnUiThread更新imageCollectorView1234567891011121314151617181920new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(\".png\")) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的：RxJava实现123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(\".png\"); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 这里代码看上去行数是变多了，但是逻辑却变得简洁了，用有文化（装X）一点的词形容叫“对仗”。RxJava 实现的是一条从上到下的链式调用，没有任何嵌套。 配合Lambda表达式使用效果拔群：RxJava+Lambda1234567Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(\".png\") &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。 4. 总结 Rxjava简介到这就差不多了，相信大家能够感受到RxJava的优势——简洁。在进入正题之前，还有一些基础要熟悉一下。下一篇文章会对基础之一的观察者模式做一个介绍，敬请关注！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"Android基于Jenkins+Git+Gradle+七牛云+QR-Code实现自动打包、上传七牛云并生成二维码","slug":"Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码","date":"2018-04-21T14:18:41.000Z","updated":"2018-08-26T07:01:43.421Z","comments":true,"path":"2018/04/21/Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码/","link":"","permalink":"https://ten-z.github.io/2018/04/21/Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码/","excerpt":"题目很长，本篇文章内容也如题目所示，介绍工作中借助自动化手段，提高团队间工作效率的一种很好的方法。","text":"题目很长，本篇文章内容也如题目所示，介绍工作中借助自动化手段，提高团队间工作效率的一种很好的方法。 版权声明：本文为博主原创文章，未经博主允许不得转载。 对于移动端的开发和测试，一般流程是测试人员向移动端开发人员要测试包，开发通过本地IDE（Android开发一般是Android Studio）打好包后通过各种媒介传给测试人员。测试人员拿到包后开始测试，一但发现bug，会通知开发人员修改，然后再重复上面的过程。 为了简化工作流程，提高效率，可以选择jenkins做持续集成。将jenkins部署在服务器上，通过jenkins实现app自动化打包。这样一来，开发人员每次只需将代码提交到版本控制系统（如git）的远程代码库上，测试人员可以根据自己需求和时间使用jenkins进行自动打包。实现开发与测试的“解耦合”。 网上关于Android开发Jenkins部署的文档有很多，不过绝大部分文档都是上传蒲公英等网站，这些网站能自动生成下载二位码并返回，可以减少部署难度，网上可参考的资料也更多，推荐优先选择这些网站。但是如果你在的公司并没有用蒲公英（比如我目前的公司），而是用的七牛云等没有返回二维码只是可以生成下载链接的网站，那么这篇文章或许能够帮到你更多。 ♨ 综上所述，没钱就要多努力，人丑就要多读书。 特别提示，下面的内容可能图比字多，因为配置这种东西我认为还是图更能说明问题。 1. Jenkins部署 这部分网上资料太多了，本人也是按照网上的教程一步一步配的。这里就不一一复制粘贴写了。可以自行百度，也有几个推荐的网址： http://blog.csdn.net/u011541946/article/details/78267097 http://www.jianshu.com/p/38b2e17ced73 http://blog.csdn.net/mabeijianxi/article/details/52680283 http://blog.csdn.net/fengshi_sh/article/details/50669754 http://www.jianshu.com/p/915c1ae69144 1.1 推荐安装插件 Branch API Plugin build timeout plugin build-name-setter Credentials Binding Plugin description setter plugin Dynamic Parameter Plug-in Environment Injector Plugin fir-plugin（可选） Git plugin（可选） GIT server Plugin(可选) Gradle Plugin Pipeline: Basic Steps Pipeline: Build Step Pipeline: Input Step Pipeline: Nodes and Processes Pipeline: Stage Step Post-Build Script Plug-in SSH Slaves plugin Subversion Release Manager plugin(可选) Timestamper Workspace Cleanup Plugin Subversion Plug-in(可选) （不一定都能用上，反正我是能装的都装了） 2. JDK、androidSDK、androidNDK等配置回到主界面-&gt;系统管理-&gt;全局属性： 配置好JDK（NDK）与PYTHON。注意：1. 相关配置需要Overall权限，在 系统管理-ConfigureGlobal Security 里配置账户权限。2. 这里的键需要和服务器环境变量内的Android SDK/NDK目录的键一致。 2.1 安装Gradle点击系统管理-Global tool configuration gradle可以直接用服务器的安装地址（如果服务器已安装），也可以选择自动安装，自动安装jenkins在第一次打包的时候回会自动下载，因此第一次打包时间会很长。 ♨ 这里有个小问题，如果gradle勾选自动安装，勾选框的上面name这个输入框尽量以后不要改动，亲自入坑测试发现仅仅改动name后，下一次打包时会从新下载gradle（原因是自动安装的目录名就是配置的的name，改动name相当于改了安装路径，gradle会在新的安装路径下重新下载安装）。 3. 创建项目并打包前面主要是在配置环境，环境搭好下面就可以配置项目了。 3.1 创建项目回到主界面-&gt;新建-&gt;构建一个自由风格的项目-&gt;ok: 3.2 git配置进入到刚创建的项目中点击“配置”，找到“源码管理”，选择“Git”。 3.3 构建–Invoke Gradle script Gradle Version:选择系统管理里配置的gradle-nameTasks:填gradle构建命令：clean是打包之前清除一下上一次编译记录。assembleRelease 或者assembleDebug，对应AS里release和debug版的包其他请自行百度gradle构建命令Pass job parameters as Gradle properties:如果需要参数化构建，需要勾选。参数化构建内容在下面一节。 3.4 参数化构建 参数化构建的主要功能是将jenkins里配置的参数注入到Android项目中的配置里，而勾选Pass job parameters as Gradle properties这个选择框可以帮我们侵入到gradle.properties文件中替换相同名称变量的值。达到入侵的效果。 由于build.gradle文件能够直接引用gradle.properties文件中的属性，因此入侵的参数如果要在build.gradle中使用的话可以直接调用。然而我们有些入侵的参数需要在java代码里用到，这就需要用到defaultConfig里面的buildConfigField方法。 上面一大波操作可能有点令人窒息，上干货： 3.4.1 先是参数配置勾选参数化构建流程，选择添加参数: 可选的参数类型有很多，这里只介绍Choice Parameter和Dynamic Parameter。其他参数类型可自行尝试。 Choice Parameter：是单选参数，配置时列出所有参数，用换行隔开，如下图： 配置完成后点击保存，回到项目页面，点击Build with Paramters，可看到刚刚配置的单选效果。开始构建后，所选择的值就会被注入到gradle.properties文件中替换相同名称变量的值。如下图： Dynamic Parameter：这个参数的值会根据你添加的Groovy脚本自动生成。配置方式如图： 其他的参数以及使用方法请自行查阅。 3.4.2 jenkins入侵参数的调用 我们知道参数化构建是将jenkins配置的参数侵入到gradle.properties文件中替换相同名称变量的值。因此，第一步就是要在Android项目下的gradle.properties文件中写入相同名称和初始值。 构建成功后，这里的EXAMPLE的值就会被jenkins上配置的EXAMPLE多选框选中的值替换。因此在程序中可以像使用gradle.properties中的参数一样使用入侵的参数。 build.gradle中调用gradle.properties的参数：build.gradle中可以直接可以调用gradle.properties中被jenkins修改过值的参数。这里以SDK_VERSION相关参数为例，如下图：gradle.properties:build.gradle: java代码中调用gradle.properties的参数：Java代码中调用gradle.properties文件里的参数需要build.gradle文件做一个桥梁，具体就是在build.gradle文件里调用buildConfigField方法。如下图： 这里的buildConfigField就是自定义一个常量，第一个参数表示类型，第二参数表示常量名，第三个参数传入的是值。这里${EXAMPLE}就是传入的gradle.properties里EXAMPLE变量的值。通过这个方法Gradle就会在BuildConfig这个类中加入常量API_HOST，如下图： 通过jenkins构建之后BuildConfig类里的的API_HOST的值就会被jenkins中配置的EXAMPLE的值替换。 下一步，在java代码里中调用BuildConfig.API_HOST，取到jenkins配置的变量的值：1public static String LOGIN_URL = BuildConfig.API_HOST 参数注入在实际工作中还是有很多用途的，比如可以用来配置不同环境、修改某些参数等等。 4. 七牛上传4.1 编译并安装七牛插件qiniu-plugin 经过上面几步出神入化的微操之后，我们已经可以在jenkins服务器上进行打包了，下面就是要将打好的apk上传到七牛云上，方便各位大佬下载（管开发要安装包的都是大佬，反正我是这么认为的）。 将apk上传七牛云有几种方法，Python好的同学可以自行研究下命令行上传。这里介绍一种老少皆宜的方法：使用七牛插件上传。但是，目前在七牛开发者中心-Jenkins七牛插件中已经找不到相关插件了，不过在万能的github上还可以找到源代码：https://github.com/ipy/qiniu-plugin 推荐一个网址可以参考：http://blog.csdn.net/fengshi_sh/article/details/50669754但是该网址里面的很多代码有误，这里亲测并修改了： 下载好源码后，建议修改QiniuPublisher.java文件 1 注释掉System.console().printf(profile.getName() + &quot;/n&quot;) 2 在第107行 123//String keyPath = path.getRemote().replace(wsPath, \"\");//String key = keyPath.replace(File.separator, \"/\");String key = path.getName(); 3 由于java8环境，还要修改pom.xml文件 12345678910111213diff --git a/pom.xml b/pom.xmlindex 0f577be..4d7c73d 100644--- a/pom.xml+++ b/pom.xml@@ -13,7 +13,7 @@ &lt;parent&gt; &lt;groupId&gt;org.jenkins-ci.plugins&lt;/groupId&gt; &lt;artifactId&gt;plugin&lt;/artifactId&gt;- &lt;version&gt;1.509.4&lt;/version&gt;+ &lt;version&gt;1.554.1&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;org.6wind.jenkins&lt;/groupId&gt; 修改完成后，就可以编译了，步骤如下： 在”终端”里执行1234567brew install maven cd /Users/apple/Downloads/qiniu-plugin-master //进入源码文件夹 export MAVEN_OPTS=\"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n\" mvn hpi:run //会运行起一个模拟环境^q //退出该模拟环境，mvn clean //删除target，第一次无需执行这个 mvn package //打包生成Tagret，新生成的.hpi文件就在target下 最后，将编译好的.hpi导入jenkins插件: 系统管理–管理插件–高级–上传插件然后在增加操作后步骤选项框里就能看到上传到七牛的选项了！ 4.2 七牛设置项（系统管理–系统设置） Accesskey/Secretkey 值可在七牛账户中查看，对应AK和SK 4.3 配置上传到七牛的相关参数增加构建后造作步骤—&gt;上传到七牛 选择上传到七牛后显示如下： 需填写的内容：七牛配置项：系统设置-七牛-设置项名称文件路径：需要上传的文件路径要上传到的 bucket：上传到七牛的空间（文件夹）名称勾选“构建失败则不上传” 上传成功后，七牛官方给出的反馈日志如图 构建后在jenkins构建项目的Console Output里能看到相关日志，证明上传成功。 5 生成七牛下载链接和二维码最终效果如下图，构建完成后会显示在项目主页的构建历史里。 5.1 生成七牛下载链接 由于请求七牛的返回值里没有具体链接，只有目标资源的最终名字。而七牛的bucket文件夹一旦创建，这个bucket的外链默认域名是固定的，因此七牛的链接需要手动把bucket下载链接拼上。（目前七牛bucket文件夹生成的临时域名需要绑定自定义域名，但是在这里并不影响我们的配置，配置了的话换成自定义域名就好。） 链接的展示需要用到：构建后操作—Set build description在这个插件里写好的链接会出现在此项目主页的构建历史里。 使用这个插件之前，需要到系统配置—安全配置中，将MarkUp Formatter修改为Safe HTML，这样展现的二维码和链接才能显示成H5标签，否则会显示成文本。 接下来配置Set build description。 第一行是正则表达式，这里的”key”:”(.*)”是用来匹配七牛返回链接里的”key”:””的值。 第二行是显示的h5代码，这里是生成了能点击的链接，\\1表示引用上面正则里的第一个值。 构建成功后生成这样的下载链接: 5.2 生成下载链接的二维码 由于七牛并不像蒲公英等网站能自动生成二维码，因此需要自己手动去生成。 在gradle版本升级到了4.1以上的时候，由于每次生成文件目录是一样的，而gradle又执行了clean命令，因此每次执行打包命令时output下的目录都会被清理（但是可以节省空间），因此用本地apk的路径生成二维码不太合适。这里选择将七牛的下载链接生成二维码，保证可控时间内链接都有效，而且可以外网访问。 按照正常逻辑来讲，应该是先上传七牛之后再生成七牛下载链接的二维码，毕竟没有上传的时候下载链接应该是不存在的。但是，由于生成二维码需要用到Execute shell这个插件，而这个插件在jenkins中是在“构建”这个模块下配置的，而七牛上传插件是在“构建后操作”这个模块下配置的。如图所示： 也就是说，在上传七牛以前就要生成下载链接二维码！！！ 是的，就是这种令人窒息的操作。方法其实很简单，这里还是用了那个小技巧：七牛的bucket(文件夹)一旦创建，这个bucket的外链默认域名是固定的。 也就是说，七牛的下载链接在上传七牛以前我们就能自己拼好(上传的文件名是自己定义的)，二维码因而也可以在上传之前生成。 下面是具体配置： 需要用到python和qrcode这个库。 第一步：下载安装Python和pipwindows和Ubuntu安装方式有点区别，请自行百度。 命令行输入：pip list 检查是否安装成功 第二步：安装Pillow由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 命令行输入：pip install Pillow 第三步：安装qrcode 命令行输入：pip install myqr 第四步：Jenlins中配置Python环境变量 进入 →系统管理 →系统设置 找到 Enviroment variables 第五步：生成二维码指令进入项目→构建→增加构建步骤，选择Execute shell（Ubuntu），或者Execute windows batch command（windows）,填写qrcode生成二维码的python命令： 格式如下：myqr apk下载链接 -n 二维码命名 -v 1 -l L -d 二维码存储路径具体指令含义详见: https://github.com/sylnsfar/qrcode 第六步：展示二维码 构建后操作 → 增加构建后操作步骤→Set build description在原有七牛下载链接上添加刚才二维码保存的图片路径： 最后点击保存。 在项目页面点击 大功告成！！！！","categories":[{"name":"自动化","slug":"自动化","permalink":"https://ten-z.github.io/categories/自动化/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://ten-z.github.io/tags/Jenkins/"}]}]}