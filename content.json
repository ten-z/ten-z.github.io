{"meta":{"title":"TEN-Z'S BLOG","subtitle":null,"description":"Thank you for reading my story","author":"ten-z","url":"https://ten-z.github.io"},"pages":[{"title":"关于我","date":"2018-03-18T01:11:26.000Z","updated":"2023-07-05T09:20:22.439Z","comments":false,"path":"about/index.html","permalink":"https://ten-z.github.io/about/index.html","excerpt":"","text":"The future is in your hands now. Thank you for visiting my blog. The English version is currently not fully translated. Please use a browser or translation software for translation. I apologize for any inconvenience this may cause. 随便写写♨ 感谢您浏览我的博客，全部文章均为个人创作，少部分文字和图片引用自别处。♨ 说实话目的性不是很强，毕竟不是大神级的专业博主，主要是最近学习或者碰到问题的整理记录。♨ 文笔略强于小学生作文，如果觉得文字读不懂的……建议反复阅读。♨ 内容上以自己理解为主，如果有理解不对的地方，欢迎批评指正。 请多关照♨ 6年有余Android开发，其中在广告行业3年，1年多在金融科技行业.♨ 独立做过app，也做过业务开发和广告SDK。架构设计和重构的经验比较多。大部分公司对于新技术更新迭代很慢，而解耦合在多任务敏捷开发中又十分重要。所以重构和架构设计作为技术端需求接手了很多，各种级别的都有。♨ 个人认为基础很重要，尤其是算法、数据结构和设计模式，是非常有助于深层次的学习的（尤其是看源码：RTFSC – Read The Fucking Source Code）。♨ 会一点H5(JS)、swift(IOS)、C#(Unity)，比较熟练的是Android(Java)和python。Kotlin刚出的时候用过，但是后来做了SDK就没怎么用了。近期会有一些项目提交到GitHub。♨ 以后还需要学的东西可能会更多，看谷歌还能整出什么新玩意吧。♨ 谷歌已经疯了。。。更新太快学不完啊。。。 联系方式♨ Github: https://github.com/ten-z♨ Blog: https://ten-z.github.io/ 膜拜大神这里是个人觉得对于学习很有帮助的大神的博客链接，当然主要是Android和Java的。♨ 郭霖的专栏：https://blog.csdn.net/guolin_blog/♨ Hongyang：https://blog.csdn.net/lmj623565791/♨ 胡凯：http://hukai.me/♨ HenCoder（扔物线）：http://hencoder.com/♨ 技术小黑屋：https://droidyue.com/♨ 刘望舒的博客: http://liuwangshu.cn/"},{"title":"categories","date":"2018-03-18T01:11:19.000Z","updated":"2018-04-25T15:25:40.000Z","comments":false,"path":"categories/index.html","permalink":"https://ten-z.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-18T01:11:02.000Z","updated":"2018-04-25T15:24:58.000Z","comments":false,"path":"tags/index.html","permalink":"https://ten-z.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一个简单的代码结构演变--使用builder模式进行业务和功能的解耦合","slug":"一个简单的代码结构演变-使用builder模式进行业务和功能的解耦合","date":"2022-04-16T03:27:34.000Z","updated":"2023-07-03T09:12:45.225Z","comments":true,"path":"2022/04/16/一个简单的代码结构演变-使用builder模式进行业务和功能的解耦合/","link":"","permalink":"https://ten-z.github.io/2022/04/16/一个简单的代码结构演变-使用builder模式进行业务和功能的解耦合/","excerpt":"builder模式是一种非常简单且容易理解的设计模式。在我们使用各种三方类库时经常会用到。本篇文章不会具体介绍builder模式。只是随着工作时间增加，感觉到平常我们使用设计模式并不是一蹴而就的，大部分都是随着业务累加或改变，才会依据不同设计模式对代码进行不同程度的调整。最近也是面试了一阵，想着正好可以举一个简单演变的例子，对日常工作中使用的设计模式做一个总结。这次以一个最简单的builder模式为例，看看我之前工作中代码结构是如何演变的。","text":"builder模式是一种非常简单且容易理解的设计模式。在我们使用各种三方类库时经常会用到。本篇文章不会具体介绍builder模式。只是随着工作时间增加，感觉到平常我们使用设计模式并不是一蹴而就的，大部分都是随着业务累加或改变，才会依据不同设计模式对代码进行不同程度的调整。最近也是面试了一阵，想着正好可以举一个简单演变的例子，对日常工作中使用的设计模式做一个总结。这次以一个最简单的builder模式为例，看看我之前工作中代码结构是如何演变的。 版权声明：本文为博主原创文章，未经博主允许不得转载。 近期正好面了某知名招聘外企的国内分公司。顺便记录下面试感受。技术一面是远程面试，跟网上说的外企面试差不多，体验非常好，无八股文。有算法但是不难，不会纠结于最优解。交流起来令人非常愉悦。但是如果不出意外的话果然要出意外了。后两轮现场面试体验不是很好。 这篇文章也是由于这次体验不太好的面试，让我觉得做过的东西、学过的技术有时间的时侯最好还是多查阅资料并记录下来。毕竟参加面试的话我们在现场没有资料可以查。如果碰到某些面试官苛刻的提问甚至质疑，以及对旧知识点的考察，只是凭借印象和记忆显然说服力和底气是不太够的（行业大神们除外）。尤其像我这种跳槽后业务和技术点跟之前又不一样的，之前的技术点也并没有时间去更新跟进。 比如这次我介绍完在上家公司使用builder模式解决灵活构造复杂对象和解耦之后（有自己画的简图），面试官连续追问了很多诸如”builder模式怎么能解耦？”、”你这个算是解耦么？”、”你们只是把view分开而已，这怎么叫解耦？”、”你再说说怎么解耦（使用builder模式）”。。。我只能说碰到这种质疑N连的面试机会应该不多，但是万一碰上的话，直接把文章发给面试官让他自己回去研究就好，没必要浪费时间。同时，我也觉得如果作为面试官的话，不要对面试者之前的架构或代码做莫名技术指导。不同公司业务技术栈选择都不尽相同，你觉得不合理在别人公司可能就是比较好的选择。 总结一波，以后自己作为面试官的话也应注意自己的话术，该提示就提示，多聆听，连续同一点的反问会让别人感觉很不好。共勉。 1.业务功能概况 啰嗦了那么多，现在就让我来介绍下此case的业务场景，以及是如何一步步演变成builder模式的。 这是一个广告视频播放的播放器模块的展示层。一般的视频播放器，就像大家平常看剧用的播放器，一般是分为如下几部分：最底层TextureView或SurfaceView，用来播放视频。上面会有各种小的控件，用来实现不同功能。比如声音按钮、播放按钮、loading图标、打底图、封面图、进度条等等，具体根据不同业务需求组件也不同。我之前的广告视频播放器上层控件就是上面那些加上一个广告尾帧页面。广告视频的ViewGroup是需要返回给上层的，上层在需要展示广告的位置addview()。 由于我们商业化广告在自己公司内部APP最开始不是标准SDK（对其他公司是SDK），而是作为一个Module在APP工程里，并且APP广告的接入也是我们商业化团队来做。因此出现了一种特殊情况，就是我们的视频广告在不同广告位展现的UI是有区别的，视频控件在不同位置也有UI等的区别。 这里多插一嘴，如果商业化团队只做SDK开发，那么广告接入应是由APP端(Publisher)自己完成的，SDK只提供统一的功能和样式。比如google的广告SDK–Admob。APP接入ADMOB广告是Publisher(Supply端)研发去做，google只会提供接入文档。与此同时，banner、插屏广告等只会对外提供一种视频广告样式，APP端(Publisher)在哪个页面调用视频样式都是一样的，毕竟google不会对你们APP不同位置的广告做不同UI开发。但是，由于公司特殊性，我们商业化团队承担了广告平台开发和APP接入两个角色，因此会出现不同广告位展示不同视频UI的需求。 2.初始的代码—三个xxxMediaView 我接手视频广告的时侯，之前的需求是只有三个广告位支持视频广告，每个位置UI有些许差异，因此代码内有三个视频广告的ViewGroup，每个ViewGroup之间差异在10%-20%。由于之前业务明确只有三个位置支持视频广告，可能是由于怕几个位置写到一起打架，因此每个位置一个view我认为还算合理。（毕竟不是自己写的也不知道当时情况，暂且这么理解） 3.改进1.0–新的广告位需要支持视频广告–分久必合 随着新的需求接入，有少量之前不支持视频的广告位需要支持。因此每一个位置一个视频MediaView的方案肯定是有问题了。以后还不清楚有多少广告位支持的情况下，view的数量肯定不能是无限的。因此第一个优化改进就是用一个MediaView统一所有视频广告展示。 对于不同位置UI或控件展示不一样的问题，（比如有些位置不显示播放进度，有的位置没有播放按钮-启动页强制自启不暂停播放），在view中通过对不同组件set状态实现。这是最直接且简单的实现方式。比如下面伪代码： 一个view123456789101112131415161718192021222324252627282930313233 public class MediaView extends MediaViewGroup&#123; private MeidaProgressBar mMediaProgressBar; private LoadingProgress mLoadingProgress; private CountDownView mCountDownView; private ImageView mSoundIcon; private ImageView mCoverView; //..... public void setSoundVisible(boolean visible)&#123; mSoundIcon.setVisible(visible); &#125; public void setSoundImage(Drawable drawable)&#123; mSoundIcon.setImageDrawable(drawable); &#125; public void setCoverImage(Drawable drawable)&#123; mCoverView.setImageDrawable(drawable); &#125; @Override public void onProgress(int progress)&#123; //示例代码，MediaView为展示层，继承的xxxViewGroup中处理播放器逻辑，这里是播放器进度的回调 //刷新播放进度条 if(mMediaProgressBar != null &amp;&amp; mMediaProgressBar.isEnable()) mMediaProgressBar.refresh(progress); &#125; ......&#125; 在支持视频广告位数量不太多的情况下，由于展示之间差异不大，所以增加的set方法还不是很多，因此对于紧急业务来说可以接受。 4.改进2.0–大量广告位需要支持视频广告–合久必分 业务发展一段时间后，尤其是前几个视频广告数据跑出效率之后，大部分都广告位要支持视频。而随着视频尾帧需求的加入，这时候这一个MediaView里有超过12个控件，初始化+各种visible和背景、颜色的set方法都堆在这一个类中，再加上视频回调接口也在此类中实现，比如刷新进度条等，会使这一个类过于冗长，可读性变差。而且每次创建MediaView对象时，new之后会调用一长串的set以满足不同位置不同的样式，实在是麻烦。 这里解释下视频尾帧。此需求是在视频播放结束后展示广告主的一些内容，如：icon，title、message、button、重播按钮等。用于引导用户二次点击广告。也是因为尾帧的加入使得整个ViewGroup中的组件过于多了。 由于每次new一个MediaView对象之后会调用一系列的set，顺其自然地就能想到一点：能否在创建对象的时侯将各个组件根据需要加入此类，每个或者几个组件放在一个独立类中，这样此MediaView中就不会有各组件及业务逻辑，这个MediaView类的代码就会大大减少。且每个组件在自己的类中处理各自展示和回调（通过接口返回）。构造每个对象时也能根据需求加入需要的组件，使得构建对象更加的灵活。虽然类会变多，但是可读性和扩展性会大大增强。且增加的类比需要展示视频的广告位置还是要少的多。 根据此思路，很容易想到一个方案：对MediaView增加构造器，通过构造器参数传入需要的组件。但是如果按照此思路的话，构造器参数至少要12个, 且还需要多个构造函数。一般构造器参数4～5个就已经算多的了，这种思路肯定无法实施。于是第二个思路就很顺其自然了：使用builder模式set个组件后build出对象，既解决构造器参数过多问题也能将组件从ViewGroup中拆到各自组件类中。 到这里builder模式的大概思路就出来了。但是由于继承了ViewGroup，并不是简单对变量赋值，这里还是做了一些改变的。在set时执行的是addView操作，并且会把接口传到mediaView构造器，以便通过接口处理视频回调。看起来有些复杂，实际很简单，后面有示例代码。 再说一些我个人的一些使用设计模式的经验吧。我在决定用任何设计模式或者架构的时侯是拒绝照本宣科的。不是觉得哪个流行、哪个高级或者大公司都在用就用哪个。对于设计模式的实现在不同业务中会做一些自己的变化。当然这些变化有的也不见得很好。主要我觉得设计模式和架构都是根据当前及可预见未来内的业务需求进行使用的。这是一个一步步演变一步步优化的过程。在业务变化过程中，设计模式和架构也是不断适应和变化的。没有最好的架构，只有适应当前业务规模和逻辑的架构。 这次的builder模式也是业务增加带来的代码结构变化。如果只有三个广告位，我认为只用三个ViewGroup也是很OK的。 对于解耦这件事，我认为解耦不仅仅是说view和module层分开才叫解耦合。我认为解耦合其实有很广泛的意思，两个业务逻辑分开两个类也算是解耦，将一个view的内部组件拆分到不同类，每个类只操作和回调一个或几个组件，相互之间不受影响也算是一种解耦合。因此，我认为这个case里的builder模式实现了MediaView各组件间的解耦一点问题都没有。 这个问题也是某位面试官一直质疑我的一点，在这里记录下。虽然我也不知道这种简单问题有啥好质疑的。下面画了张图，大体总结下我们这个ViewGroup的类的拆分。 这里将我们所有组件根据业务功能划分成了6个大组件。在new每个MediaView的时候通过set不同组件实现不同功能需求的MediaView。也很好的确保了每个MediaView只包含相应功能的组件，减少冗余。下面是代码： 拆分的MediaView1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MediaView extends MediaViewGroup&#123; private CoverImageInterface coverImageInterface;//封面组件接口 private ContinueViewInterface continueViewInterface;//重播接口 private EndFrameInterface endFrameInterface;//尾帧接口 private MiddleFrameInterface middleFrameInterface;//中间组件层接口，包含声音，进度条等 private LoadingInterface loadingInterface;//加载接口 private BottomImageInterface bottomImageInterface;//打底图接口 private MediaView(Builder builder)&#123; this.coverImageInterface = builder.coverImageInterface; this.continueViewInterface = builder.continueViewInterface; this.endFrameInterface = builder.endFrameInterface; this.middleFrameInterface = builder.middleFrameInterface; this.loadingInterface = builder.loadingInterface; this.bottomImageInterface = builder.bottomImageInterface; &#125; public static class Builder&#123; private CoverImageInterface coverImageInterface;//封面组件接口 private ContinueViewInterface continueViewInterface;//重播接口 private EndFrameInterface endFrameInterface;//尾帧接口 private MiddleFrameInterface middleFrameInterface;//中间组件层接口 private LoadingInterface loadingInterface;//重播接口 private BottomImageInterface bottomImageInterface;//打底图接口 public Builder setCoverImage(CoverImage coverImage) &#123; //CoverImage实现了CoverImageInterface，这里将interface传到MediaView用来执行业务逻辑回调 //然后把此View， add到当前viewGroup //因此set顺序很重要，根据set顺序不同能构建出不同样式的view。也有了很强的灵活性 this.coverImageInterface = coverImage; this.addView(coverImage); return this; &#125; public Builder setMiddleFrame(MiddleFrame middleFrame) &#123; //原理同上，这里以进度条progress回调来展示接口回调的作用 this.middleFrameInterface = middleFrame; this.addView(middleFrame); return this; &#125; //...其余set原理同上 public MediaView build()&#123; return new MediaView(this); &#125; &#125; @Override public void onProgress(int progress)&#123; //示例代码，MediaView为展示层，继承的MediaViewGroup中处理播放器逻辑，这里是播放器进度的回调 //不在MediaView中处理播放器回调刷新进度条逻辑，将此业务逻辑放到MiddleFrameInterface中，由其实现类MiddleFrame实现刷新进度条逻辑 //这样就可以使每个控件类实现各自业务逻辑，减少MediaView中大量的业务逻辑代码。MediaView与控件业务解耦合 if(middleFrameInterface != null) middleFrameInterface.onProgress(progress); &#125;&#125; 下面是MiddleFrame事例代码，从MediaView中分离出自己类的的业务职责。 MiddleFrame12345678910public class MiddleFrame implements MiddleFrameInterface&#123; private MeidaProgressBar mMediaProgressBar; @Override public void onProgress(int progress)&#123; //在此实现ProgressBar刷新逻辑。将本来在MediaView中的逻辑拆分至此类中 if(mMediaProgressBar != null &amp;&amp; mMediaProgressBar.isEnable()) mMediaProgressBar.refresh(progress); &#125;&#125; 以上就是我使用builder模式的一些总结。由于离职有一段时间了，没法写出完整的代码。大家意会即可。主要是分享下自己使用设计模式的演变过程。毕竟每个人遇到的业务逻辑都会有所区别。大家应该按照自己业务所需作出自己的改变。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://ten-z.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://ten-z.github.io/tags/设计模式/"}]},{"title":"Hexo+Github博客移植及白屏问题","slug":"Hexo-Github博客移植及白屏问题","date":"2022-03-17T02:23:55.000Z","updated":"2022-07-09T15:12:11.728Z","comments":true,"path":"2022/03/17/Hexo-Github博客移植及白屏问题/","link":"","permalink":"https://ten-z.github.io/2022/03/17/Hexo-Github博客移植及白屏问题/","excerpt":"最近想把之前在github上搭的博客整一整。由于换了电脑，移植过程中出现了各式各样奇葩的问题。现记录下，防止以后移植踩坑。 MAC配置环境变量的坑也记录在此。","text":"最近想把之前在github上搭的博客整一整。由于换了电脑，移植过程中出现了各式各样奇葩的问题。现记录下，防止以后移植踩坑。 MAC配置环境变量的坑也记录在此。 版权声明：本文为博主原创文章，未经博主允许不得转载。 1.github repositories上是hexo g生成的文件，不是本体。 最近由于换了电脑，想要把之前的博客移植到另一台电脑，在另一台电脑上编辑上传。一开始误以为直接git clone之前在GitHub上的repositories就行，结果clone下来发现没有之前文章的md文件。上网搜索后发现需要把之前电脑的内容全部移植才行。 把之前前脑的全部文件copy或全部git push上传github再转移到新电脑–无论什么套路把全部文件搞过去就行。在新电脑中重新配置github的ssh和hexo。推荐Hexo官方文档：https://hexo.io/zh-cn/docs/ 2.上传后打开白屏问题 在本地hexo s打开正常，hexo d传到github后打开ten-z.github.io发现直接白屏（图忘截屏了，就是全白），且没有loading（不是网络不好），页面也没有任何报错。 根据知乎这篇文章： 以此检查，在index.html这里发现问题。我的GitHub上的index.html是个空文件，里面没有内容，大小为0byte。 又根据此文章：检查hexo插件未发现问题。 最后根据hexo 生成的publish中html都是空的？ 发现似乎是nodejs版本不对。我在新搭hexo的时侯用的最新版本。重新安装hexo12+版本后解决白屏问题。 附：node版本切换 3. github pages build failure 在github次项目的的action中可以看到构建的记录，点开发现是400 Error。 加上最近github经常打不开。应该是github自己服务崩溃。稍后再试，成功。 4.safari不支持webp格式 不知道是不是版本问题，PS导出的webp格式图片上传博客在Safari上显示不出来，在chrome上展示正常。 5.MAC环境变量配置问题 我的MAC终端默认是.zsh。可以通过bash命令切换。但是奇怪的是没有~/.bash_profile和～/.zshrc文件。不太清楚为什么一个配置文件都没有，通过路经进到文件夹查也查不到。 像Java这种通过安装包安装的还好，装完后在终端后就能直接用。Python环境也没有问题。但是通过pip安装的各种插件就完全用不了，必须自己配置环境变量。配置起来还是比较简单，创建～/.zshrc文件添加PATH就好，用:隔开。 但有一个坑是路径选择问题。因为pip安装的插件，例如Atom中beauty插件需要的isort和autopep8，安装后通过where命令是找不到路径的。而安装时终端里显示的路径xxx/lib/xxx只是安装路径，不是需要配置的环境变量！！！。这里坑了我很久。要配置的变量即脚本文件在和lib文件同级的xxx/bin/xxx中，环境变量要添加的是bin文件夹。但是没有任何地方提示要配bin文件夹，也没有任何地方提示有bin文件夹，让我找了半天。添加lib文件夹一直会报No permission(更改文件夹权限无效的那种)和No such File（类似）。改成bin文件夹后问题全部消除。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://ten-z.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ten-z.github.io/tags/Hexo/"}]},{"title":"MP4秒播优化-MOOV BOX位置优化","slug":"MP4秒播优化-MOOV-BOX位置优化","date":"2022-03-15T04:17:16.000Z","updated":"2022-04-16T07:43:58.168Z","comments":true,"path":"2022/03/15/MP4秒播优化-MOOV-BOX位置优化/","link":"","permalink":"https://ten-z.github.io/2022/03/15/MP4秒播优化-MOOV-BOX位置优化/","excerpt":"之前的工作中负责了视频广告业务，也顺带学习了下音视频相关的基本知识。这篇文章是在支持了音视频基本功能后，进行视频广告启播优化时学习和调研的一次总结。","text":"之前的工作中负责了视频广告业务，也顺带学习了下音视频相关的基本知识。这篇文章是在支持了音视频基本功能后，进行视频广告启播优化时学习和调研的一次总结。 版权声明：本文为博主原创文章，未经博主允许不得转载。 1.优化的目的 本次优化基于提前mp4文件moov box的位置，可以大幅提升在线视频广告/未缓存视频的启播效率。 目前常见缩短视频起播时长优化点：https://zhuanlan.zhihu.com/p/112773041还有一篇微信团队的视频播放优化浅析也很不错：https://cloud.tencent.com/developer/article/1831098 2.Moov耗时原因 首先mp4是由很多box组成的，在moov box中存储了描述音视频格式如视频宽高、分辨率、码率等相关的格式信息，先要拿到这些信息才能播放。如果将moov box放在文件的前面，那么只需要通过一次http请求就可以直接读取到，进而执行解封装。而如果在moov box放在文件的后边，但关键是播放器不知道它放在后面，这就需要先发起一次http请求读开头部分数据，发现是mdat，进而会seek到文件后边位置，读取moov box，然后再seek到文件前边的mdat，从新读取mdat。每发生一次seek就会重新发起一次http connetion请求。因此moov box放在后边比放在前边多了2次http connection。 如果在起播过程中发生了http re-connection耗时肯定会增加，而且http connection的耗时基本是不可优化的，所以要避免http re-connection的发生。因此将mp4中moov box提前会有比较好的优化效果。 这里关于 “如果一开始就读取到mdat后是否会seek到末尾”问题，我在不同的文章中发现了不同的结论。有文章说如果一开始就读取到mdat后会一直把mdat请求完毕，也就是内容全部下载完后读取moov-解封装-播放。播放等待时间为内容下载耗时。我看的这篇文章写的是读到mdat后会seek到末尾，再seek回mdat，耗时为http connection耗时。我查阅其他文章后目前的结论是：是否可以seek到数据末尾请求数据需要服务端支持。如果只是把视频文件简单存放在服务端，请求的时候是没法seek也就是不能先请求最后的数据的。如果服务端支持seek，那么则可以实现先请求最后的box数据，再请求前面的数据，最后合包时组合成原始数据。 3.解决方案 线上方案：在mp4文件上传到服务器之后，重新封装，把moov_box放到mdat前面。此方案实施在广告投放平台，由后端和视频团队执行。 本次调研方案：本次调研为纯客户端调研。首先找了一段测试视频广告1，用mp4info确认视频1的moov_box在最末端。然后从网上找了一段能将mp4中的moov box提前的python脚本，在本地执行将视频1的moov_box提前生成视频2。将视频1和视频2上传广告测试平台。在app中用同一广告位分别拉取两个视频广告，测试启播时间。 4.调研结果 设备：三星J600G app：ShareKaro(v1.1.69) 播放器：mediaplayer 广告：4146(转码后)/4364(转码前)。强拉。时长27s，大小1392KB mp4info解析moov位置：转码前： 转码后： 可以看到转码后moov位置提到mdat之前 参考耗时：startPreparing(自己的tag，在对应mediaplayer的prepareAsync前)和onPrepared(对应mediaplayer的onPrepared状态)之间为mediaplayer起播内部耗时(解协议、解封装)。转码前： 转码后： 从调研结果看，调整后的启播时间能缩短1个数量级左右。视觉上对于视频启播时间缩短有明显的效果。 参考文档：https://blog.csdn.net/peckjerry/article/details/43021629https://zhuanlan.zhihu.com/p/148854913https://zhuanlan.zhihu.com/p/148855603","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"https://ten-z.github.io/tags/音视频/"}]},{"title":"慢下来的时光","slug":"慢下来的时光","date":"2022-03-14T05:29:22.000Z","updated":"2023-07-05T07:15:58.349Z","comments":true,"path":"2022/03/14/慢下来的时光/","link":"","permalink":"https://ten-z.github.io/2022/03/14/慢下来的时光/","excerpt":"午睡操场传来蝉的声音多少年后也还是很好听 ——《蒲公英的约定》","text":"午睡操场传来蝉的声音多少年后也还是很好听 ——《蒲公英的约定》 版权声明：本文为博主原创文章，未经博主允许不得转载。 认真投决定命运的硬币 却不知道到底能去哪里 19年中旬入职了新公司 21年9月辞职了 公司名就不说了 加班严重 精神压力巨大 加上晚上休息不好 白天头晕气短 下午4点多就饿到不行 午饭和晚餐之间需要大吃一顿 有时候下午忘了吃东西甚至饿到眼花 结果就是体重直线飙升 去医院全身检查了一圈 什么问题都没有 除了肥胖 医生说每天早点休息 工作压力不要那么大 我只能苦笑的嗯了一声 解决方法似乎愈加清晰 从医院出来的那一刻 看了看工作群的信息 我抛了一枚硬币。。。 将愿望折纸飞机寄成信 因为我们等不到那流星 休息了一个月 基本症状都没有了 看到了一些焦虑症的新闻 感觉和之前的症状很像 但是不工作好像就没有焦虑 计划学学英语考考试 毕竟留学还是要去的 只是新西兰一直不开边境 这段工作的感触大概就是努力也要选对方向 选择自己适合的工作 毕竟也看到很多40多岁每天22点下班的人精神抖擞 这就是因人而异吧 说好要一起旅行 是你如今 唯一坚持的任性 去海南自驾 绕了东边线开了半个岛 在海口租车 沿东线环岛高速 经文昌 万宁 陵水 保亭 最后到三亚还车 人少开车就是爽 第一天还不敢踩油门 第二天就快超速了 雪弗兰迈锐宝XL莫名还挺好开的 文昌东郊椰林椰子鸡也算一绝 在神州半岛的灯塔晒成狗 在保亭的温泉看 披荆斩棘的哥哥 在海口骑车去做核酸 蹭朋友的车去了澄迈 慢下来的才叫生活吧","categories":[{"name":"日常","slug":"日常","permalink":"https://ten-z.github.io/categories/日常/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://ten-z.github.io/tags/日常/"}]},{"title":" 一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava","slug":"一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava","date":"2019-07-01T04:39:09.000Z","updated":"2019-07-01T09:35:12.000Z","comments":true,"path":"2019/07/01/一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava/","link":"","permalink":"https://ten-z.github.io/2019/07/01/一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava/","excerpt":"前面Rx系列的五篇文章从源码的角度分析了RxJava几个主要功能的具体实现逻辑。在学习了RxJava源码之后的一段时间里，我阅读了Rx相关更多的文章，以及通过面试、技术分享等经历，一直在思考一个问题，就是如何总结RxJava的思想，其实就是如何讲清楚RxJava。尤其对于面试这种情况来说，很难在短时间内细抠源码，如何让面试官知道你学习过源码而不是只有使用的经验。以及在分享的时候如何能让听者快速理解。这篇文章就是我近期对这类问题的一个思考总结，基于波浪事件流和模块化的思路来分析RxJava。","text":"前面Rx系列的五篇文章从源码的角度分析了RxJava几个主要功能的具体实现逻辑。在学习了RxJava源码之后的一段时间里，我阅读了Rx相关更多的文章，以及通过面试、技术分享等经历，一直在思考一个问题，就是如何总结RxJava的思想，其实就是如何讲清楚RxJava。尤其对于面试这种情况来说，很难在短时间内细抠源码，如何让面试官知道你学习过源码而不是只有使用的经验。以及在分享的时候如何能让听者快速理解。这篇文章就是我近期对这类问题的一个思考总结，基于波浪事件流和模块化的思路来分析RxJava。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava 1.前言 再来说下为什么总结这篇文章。我在看各种源码并做技术分享的时候，一直有种体会，就是自己看源码或者是跟着别人讲解的博客看源码的时候，感觉理解还是比较容易的，但是一旦跟别人分享的时候，就感觉自己没讲清楚。所以我一直在反思，为什么会出现这种情况，如何做到所谓的“深入浅出”。总结起来有以下两点： 第一是表达能力。客观来说程序员这个行业对表达能力的要求不是很高，我认识的很多程序员朋友都是十分内向、不善于表达的。我之前的技术leader肖老板经常跟我们讲，程序员应该多去做技术分享，多去自信的表达。这个问题只能说多去练习吧，用不到像发布会似的那种口才，但是一定要自信，强烈的自信才能游刃有余。 第二也是最重要的一点，就是对源码思想的理解。代码这种东西表达的其实是抽象的逻辑，而听你讲解的人可能大多数都是没看过源码甚至没涉猎你所讲技术点的人，因此对于讲源码这种事来说，最重要的是把抽象的代码中的逻辑思想 讲清楚。如果一次技术分享就是把前五章的源码堆上去分析的话，我觉得大部分听者都会对你投来疑惑的点头和礼貌的微笑的。 思想的理解是没有标准的答案的，或者说，从不同的层面和维度能总结出不同的东西。这个问题只能是说多去看源码，看别人的文章，多去分析和总结。我对RxJava思想的理解可能也不如别人深刻，只能说不断学习，不断进步吧。 2.基于波浪事件流的思路 先来说下什么是“事件流”。其实在“一起读RxJava源码（五）——线程调度”中，我分析源码的方法就是按照从事件的产生到接收的流程为顺序进行的，在最后总结出的流程图（如下）也能看到RxJava代码执行时事件传递的流程。因此“事件流”其实就是事件传递的流程，“事件”也就是RxJava扩展的观察者模式中的事件（详见第三章）。概括来说，事件在被观察者的call()方法中发送，在观察者的onNext()方法中接收，通过subscribe()方法链接。 我总结了一种更直观的方式总结“事件流”，就是：在RxJava代码调用层看RxJava代码的执行顺序。这句话可能有点拗口，但其实并不难理解，就是表面意思。结合RxJava具体代码来看我觉得会更清楚。这里以第五章RxJava线程调度的代码为例：线程调度基本实现1234567891011121314151617181920212223242526Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;hello rxjava&quot;); subscriber.onCompleted(); &#125;&#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); textView.setText(s); &#125; &#125;); 我们前五章的内容其实是深入每个方法，研究方法内部的调用逻辑。现在把所有调用的方法都当做“黑盒”，不深入进去。站在这个代码调用层从整体来看下： Rx代码执行时先“向下”执行至.subscribe方法，每次创建一个新的被观察者；而后从.subscribe开始执行“触发事件”流程，此时会“向上”执行至OnSubscribe的call()方法；然后在call()方法中(subscriber.onNext)发送事件，再次“向下”执行事件下发流程，执行至.subscribe的onNext()接收事件，整个Rx调用结束。 从上可见，如果在RxJava代码调用层来看RxJava代码的执行顺序的话，Rx代码其实是经历了“向下”、“向上”、再次“向下”三个流程，从Observable.create开始最后执行至onNext结束。现在可以回到前几章，再看下转换操作符和线程调度的实现代码，尤其是上面的那个示意图。从那张图中也很明显的可以看出这三个流程。 这三个流程总结起来就是：1、创建对象流程（被观察者）：第一次“向下”的流程2、事件触发流程：“向上”的流程3、事件下发流程：第二次“向下”的流程 下面是三个流程的示意图，应该可以加深理解： 这三个流程连起来冲图上看就是个波浪的形状，因此我就简单叫做波浪形事件流。RxJava的各操作符都可以抽象成这三个流的逻辑，也是因为如此，才能把各个操作符无缝链接起来，形成传说中的链式调用。 3.基于模块化的思路 这里的“模块化”并不是架构中的那种模块化，这里指的是由于RxJava每个操作符是基于波浪事件流实现的,都可以抽象成这三个流的逻辑，因此可以向拼图一样，将各模块拼起来分析代码调用的逻辑。给张图就明白了： 从RxJava源码的角度来看，RxJava每个操作符都可以形成这三条流的本质其实在前面两章讲过了，就是每一个操作符都是返回一个新的被观察者Observable；并且在相应“上行”流中会创建新的观察者Subscriber，并与上一级被观察者Observable建立依赖关系。整体上看，就是每个操作符都是在目标观察者和被观察者之间加了一层。相当于从A和C的一层订阅变成了ABC的两层订阅。这样使得无论加入多少个操作符，都是按照波浪形事件流的顺序执行的。 4.利用两种思路分析复杂问题 前面分析了这么多，来看下用基于波浪事件流和模块化的思路分析RxJava的优点在哪。下面这个例子也不算很复杂，只是把之前讲过的操作符重新组合了一下，尝试判断下1~6号位置执行的线程。稍复杂的Rx调用123456789101112131415161718192021222324252627282930Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(..1.); subscriber.onCompleted(); &#125; &#125;) .map(..2.) .subscribeOn(Schedulers.newThread()...8) .map(..3.) .subscribeOn(Schedulers.newThread()...7) .map(..4.) .observeOn(Schedulers.newThread()...9) .map(..5.) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber() &#123; @Override public void onCompleted() &#123; ... &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; ..6. &#125; &#125;); 源码逻辑好的同学应该能很快看出来，1~4执行在8的线程,5执行在9的线程，而6执行在main线程。7号的线程其实是没有用的，为什么呢？在大部分博客中会有这样一段话：多次调用subscribeOn()只有第一次的有效, 其余的会被忽略；而每调用一次observeOn() , 线程就会切换一次。但是绝大部分博客并没有分析为什么。如果利用波浪事件流和模块化的思路来看，就十分好理解了，一张图就能说明白： 如上图所见，7的线程是存在的，只不过7的线程只是切换了8的线程，并没有做任何操作而已。为了验证上面的结论的正确性，我做了一点复杂的操作：在subscribeOn之后输出线程名，以及每个操作符执行目标代码时也输出线程名，验证我们上述结论。具体的代码这里写不下了，我传到了我的github上，有兴趣的同学可以看下：https://github.com/ten-z/MyRxJavaDemo。 我这里用了两种方式实现： 一种是继承Observable类，自己实现了一个在事件触发流程中调用方法的操作符myOperator，在调用方法中输出线程名。将此操作符放在subscribeOn之前调用，就可以打印出此subscribeOn切换的线程。结果如下： 第二种是利用AOP思想，使用AspectJ实现代码注入。在subscribeOn()执行切换线程后，调用SubscribeOnSubscriber.call之前切入，输出日志。结果图如下，可以看出跟我们用波浪事件流和模块化的思路推出的结果是一致的： 当然，上面只是举个例子。基于波浪事件流和模块化的思路的主要目的是帮助工程师快速理解RxJava。当然，在看源码时最根本还是要看懂源码，甚至总结出自己的思想才可能对RxJava有更深的理解。 5.总结 RxJava系列兜兜转转写了有六个专题了，主要是我自己对Rx的一些思考。当然细心的同学应该发现，我这几篇文章举例都是基于RxJava1.0的，但实际上RxJava1.0在18年3月已经停止更新了，2.0目前是Rx的主力，但是2.0和1.0主要的思想还是一样的。由于我本人看源码的时间比较久远了，那时候还是1.0的天下，因此这系列文章我还是以最熟悉的1.0的使用来举例的，主要还是为了总结一个思想。我相信无论Rx出到几，基本思想都不会有太大变化。以后有机会，我会再总结更新版本的Rx间的差异。大家加油！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"斐波那契数列(Fibonacci sequence)的6种解法","slug":"斐波那契数列-Fibonacci-sequence-的6种解法","date":"2019-06-17T23:50:20.000Z","updated":"2019-07-07T06:47:46.000Z","comments":true,"path":"2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/","link":"","permalink":"https://ten-z.github.io/2019/06/18/斐波那契数列-Fibonacci-sequence-的6种解法/","excerpt":"最近在刷Leetcode，目前在“Explore”中出了很多学习和面试的专题，刷了几个系列感觉非常不错。“斐波那契数列”是一个很经典的问题了，无论是讲解递归还是动态规划的文章中都时常能看到。可以用斐波那契数列求解的题目也有很多，比如“爬梯子”和“兔子繁殖”等经典问题。在此主要是记录一下解决“斐波那契数列”类似问题的6种思路。","text":"最近在刷Leetcode，目前在“Explore”中出了很多学习和面试的专题，刷了几个系列感觉非常不错。“斐波那契数列”是一个很经典的问题了，无论是讲解递归还是动态规划的文章中都时常能看到。可以用斐波那契数列求解的题目也有很多，比如“爬梯子”和“兔子繁殖”等经典问题。在此主要是记录一下解决“斐波那契数列”类似问题的6种思路。 版权声明：本文为博主原创文章，未经博主允许不得转载。 本篇文章中的所有事例在我的github中均有完整的代码实现，链接为：https://github.com/ten-z/Fibonacci-Sequence 0. 前言斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*)。 百度百科中关于斐波那契数列的描述 一般斐波那契数列相关的问题都是给出n求F(n)，下面解法也都是针对这种题型来的。 1. 方法一：递归/回溯/暴力解法（Recursion）由于斐波那契数列有很明确的递归关系(F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*))和递归终止条件(F(0)=0， F(1)=1，有的会用F(2)=1)。因此，很容易用递归暴力解决。 越抽象的问题用图来说明会比较容易理解，下面以计算f(4)为例，计算f(4)递归执行树如下图： 通过这个图以及递归关系很容易看出，递归的逻辑是：要求f(n)，就要先求出f(n-1)和f(n-2)的值；而求f(n-1)，又要先求出f(n-2)和f(n-3)的值，这样一步一步往前寻找，直到找到f(1)=1和f(2)=1为止。具体代码实现如下： 递归解法1234567public static int fibonacci(int n) &#123; if (n &lt; 2) &#123; return n; &#125; else &#123; return fibonacci(n-1) + fibonacci(n-2); &#125;&#125; 时间复杂度：$O(2^n)$空间复杂度：$O(n)$ 2. 方法二：记忆化搜索（Recursion with Memoization）记忆化搜索本质是对递归算法的剪枝优化。还是以计算f(4)为例，下图为计算f(4)的递归执行树，可以看出求解f(4)时存在着大量的重复计算： 为了解决这些重复计算，可以将第一次求出的结果存储起来，一般来讲是按下标存放在memo数组中。下次计算前先去数组相应位置查找，如果有结果，就可直接返回，避免重复的计算。代码也很简单：记忆化搜索123456789101112131415161718192021 public static int fibonacci(int n) &#123; if(n&lt;2)return n; //初始化memo数组,从1～n，所以长度为n+1 int[] memo = new int[n+1]; return fibonacciMemorize(n, memo);&#125; //用memo数组存储计算结果public static int fibonacciMemorize(int n, int[] memo) &#123; if(n==1 || n==2)&#123; return 1; &#125; //如果memo(n)有值，直接返回memo[n]，减少递归次数，由于n从1开始，memo[0]=0不受影响。 if(memo[n]==0)&#123; //如果当前f(n)没被计算过，则计算后将结果存入memo[n] memo[n] = fibonacciMemorize(n-1, memo) + fibonacciMemorize(n-2, memo); &#125; return memo[n];&#125; 时间复杂度：$O(n)$空间复杂度：$O(n)$ 3. 方法三：动态规划（Dynamic Programming）根据动态规划的定义，由于这个问题可以分解成子问题，它包含了子问题的最优性质，即它的最优解可以从子问题的最优解中有效地构造出来。因此我们可以用动态规划来解决这个问题。 不过定义理解起来有点复杂，其实动态规划的解法可以看作是记忆化搜索思想的逆向思路。可以自行先打印下方法二中memo数组赋值的顺序，可以发现：memo数组是从memo[1]，memo[2],memo[3]…memo[n]依次赋值的，每一位置的值为前两个位置值的和。而memo[n]就是我们要求的f(n)。所以可见，如果抛弃递归的思路，仅在数组中用循环也可以依次计算数出组中的值，最后求得f(n)。具体点说，就是由于memo[1]=1和memo[2]=1可知，所以可以先算出memo[3] = memo[2] + memo[1],然后memo[4] = memo[3]+memo[2]…,直到求出memo[n]。而memo[n]就是要求的f(n)。 总结一下：递归和记忆化搜索的思路是：求f(n),要先求出f(n-1)和f(n-2)的值；而求f(n-1)，又要先求出f(n-2)和f(n-3)的值，这样一步一步往前寻找，直到找到f(1)=1和f(2)=1为止。而动态规划的思路是：求f(n)，由于我们已经知道f(1) = 1,f(2) = 1，所以可以先求出f(3) = f(1) + f(2)，再求f(4)…这样一步一步从前向后直到求出f(n)。 代码如下：动态规划，用循环代替了递归123456789101112131415161718public static int fibonacciDynamic(int n) &#123; if (n &lt; 2) &#123; return n; &#125;//初始化memo数组,从1～n，所以长度为n+1 int[] memo = new int[n + 1];//已知的0和1位置的值，代替递归终止条件。 memo[0] = 0; memo[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; memo[i] = memo[i - 1] + memo[i - 2]; &#125;//memo[n]即f(n)的值 return memo[n]; &#125; 时间复杂度：$O(n)$空间复杂度：$O(n)$ 4. 方法四：斐波那契数（Fibonacci Number）这个方法本质是对方法三在空间复杂度上的优化。在动态规划的解法中，我们用了一个长度为n+1的memo数组来辅助计算f(n)，但是其实f(n)的值只跟f(n-1)和f(n-2)两个数有关，那么前面的n+1-3个数据能不能优化呢？ 斐波那契数这个方法就是通过两个索引来代替memo数组，在每次循环之后更新两个索引的值，这样可以使空间复杂度降低至$O(1)$的级别。 废话不多说，上代码：斐波那契数1234567891011121314151617 public static int fibonacciNumber(int n) &#123; if (n &lt; 2) &#123; return n; &#125;//用first和second存储每次的memo[n-1]和memo[n-2],不断更新first和second的值，代替memo数组 int first = 0; int second = 1; for (int i = 2; i &lt;= n; i++) &#123; int third = first + second; first = second; second = third; &#125;//最后一次循环交换后，f(n)==second return second; &#125; 时间复杂度：$O(n)$空间复杂度：$O(1)$ 斐波那契数列的常规方法主要就是上面四种，经过一步一步的优化，将时间复杂度降至O(n)，空间复杂度降至O(1)。后面介绍的两种特（qi）殊（pa）方法主要是针对时间复杂度的优化。 5. 方法五：矩阵法（Binets Method）矩阵法的本质是将斐波那契数列问题转化为指数计算的问题，而求解例如Q的n次方的问题可以很容易的使用二分法的思路，将时间复杂度降为$O(logn)$。先看一下矩阵的乘法计算：已知:$$A=\\left[\\begin{matrix}a &amp; b\\\\c &amp; d\\end{matrix}\\right],B=\\left[\\begin{matrix}e\\\\f\\end{matrix}\\right]$$所以：$$AB=\\left[\\begin{matrix}ae+bf\\\\ce+df\\end{matrix}\\right]$$反之亦然。 根据上面的规则，可以将斐波那次数列作如下改动： $$\\left[\\begin{matrix}f(n)\\\\f(n-1)\\end{matrix}\\right]=\\left[\\begin{matrix}f(n-1)+f(n-2)\\\\f(n-1)\\end{matrix}\\right]=\\left[\\begin{matrix}f(n-1)×1+f(n-2)×1\\\\f(n-1)×1+f(n-2)×0\\end{matrix}\\right]=\\left[\\begin{matrix}1&amp;1\\\\1&amp;0\\end{matrix}\\right]×\\left[\\begin{matrix}f(n-1)\\\\f(n-2)\\end{matrix}\\right]$$ $$=….=\\left[\\begin{matrix}1&amp;1\\\\1&amp;0\\end{matrix}\\right]^{n-1}×\\left[\\begin{matrix}f(1)\\\\f(0)\\end{matrix}\\right]=\\left[\\begin{matrix}1&amp;1\\\\1&amp;0\\end{matrix}\\right]^{n-1}×\\left[\\begin{matrix}1\\\\0\\end{matrix}\\right]$$ 如果记$Q=\\left[\\begin{matrix}1&amp;1\\\\1&amp;0\\end{matrix}\\right]$，那么$$\\left[\\begin{matrix}f(n)\\\\f(n-1)\\end{matrix}\\right]=Q^{n-1}×\\left[\\begin{matrix}1\\\\0\\end{matrix}\\right]$$由于乘数是$\\left[\\begin{matrix}1\\\\0\\end{matrix}\\right]$，所以f(n)的值就是计算出$Q^{n-1}$的矩阵后最左上角那一位的值。 如此，斐波那契数列就转换为了求Q的n-1次方的问题。 求解$Q^{n-1}$的问题最主要的思路就是二分法，将指数n每次二分，根据当前n的奇偶不断递归，偶数就直接除以2，并将结果自己乘自己；奇数因为除不尽，结果还得再多乘一次Q。当然，这里的乘法也是矩阵乘法，需要自己写出相应的方法。示意图如下： 下面是具体代码： 矩阵法--指数二分1234567891011121314151617181920212223242526272829 public static int fibonacci(int n, int[][] q) &#123; if(n&lt;2)return n; int[][] res = powRecursion(n-1, q); return res[0][0]; &#125; //递归实现的pow()，每次将指数二分 public static int[][] powRecursion(int n, int[][] q) &#123; if(n == 1)return q;//每次指数/2 int[][] r = powRecursion(n&gt;&gt;1, q);//奇数的话要多乘一个底数，偶数则不用 if ((n &amp; 1) == 1)&#123; return multiply(multiply(r,r), q); &#125;else&#123; return multiply(r,r); &#125; &#125; //矩阵乘法的实现 public static int[][] multiply(int[][] a, int[][] b) &#123; int[][] c = new int[2][2]; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; &#125; &#125; return c; &#125; 对于求解$Q^{n-1}$，或者说普遍求解$Q^{n}$这类问题，除了上面比较容易理解的递归之外，还可以利用二进制的一些技巧，将指数进行二进制的拆解。举个例子： 假设求：$Q^{11}$。我们已知11=1011=1000+0010+0001(拆解成二进制的和)所以$$Q^{11}=Q^{8+2+1}=Q^8×Q^2×Q^1=Q^{2^3}×Q^{2^1}×Q^{2^0}$$ 也就是说，将11转换成二进制，为1的位置就是底数要乘的位置，而由于二进制出现在幂的位置上，所以反应在Q上就变成前一位乘积的平方的关系。 逻辑稍有点复杂，还是上面的例子，为方便发现规律，假设Q = 3：$$3^{0001}=3$$$$3^{0010}= 3×3 = 9$$$$3^{0100} = 9×9 = 81$$$$3^{1000} = 81×81 = 6561$$所以：$$3^{1011} = 3×9×6561 = 177147$$ 具体执行逻辑为：将指数转换成二进制后，从右向左查看二进制每一位是否为1，如上所示，第一位为1，那么最终结果乘上$3^1$；继续看第二位，此时不用再计算$3^2$，直接将上一位（第一位）的结果自乘一下就是第二位的结果。同时由于第二位为1，最终结果也乘上第二位算出的结果；继续看第三位，也是一样的先计算出第三位的结果，由于第三位等于0，那么最终结果不乘入；到第四位，根据第三位的结果自乘算出第四位的结果，第四位是1，将第四位乘入最终结果。 写成代码就是如下的逻辑：矩阵法--指数二进制拆分123456789101112131415 public static int[][] powBinary(int n, int[][] a) &#123;//初始化矩阵,示意写法 int[][] ret = &#123;[1, 0&#125;], [0, 1]&#125;; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; //二进制中1的位置需要乘入结果，其结果等于低（前）一位结果的平方 ret = multiply(ret, a); &#125; //右移，看二进制指数高一位是否为1 n &gt;&gt;= 1; //无论高一位是否为1，都先算出结果，等于当前结果的平方 a = multiply(a, a); &#125; return ret; &#125; 注意：两种方法调用的时候是n-1：因为是$Q^{n-1}$。 时间复杂度：$O(logn)$空间复杂度：$O(1)$ 6. 方法六：公式法（Fibonacci Formula）先给出第n项斐波那契数列f(n)的通项公式:$$F_n=1/\\sqrt{5}{\\Bigl[\\Bigl(\\frac{1+\\sqrt{5}}{2}\\Bigr)^n-\\Bigl(\\frac{1-\\sqrt{5}}{2}\\Bigr)^n\\Bigr]}$$ Leetcode里给出的标准的推导方法是：由于F(n+2) = F(n+1) + F(n)，假设$$F_n=a^n$$可以得到：$$a^{n+2}=a^{n+1}+a^n$$简化下可得$a^{2}-a-1=0$,这样a的解就是:$$a=\\frac{1\\pm\\sqrt{5}}{2}$$所以f(n)的通解为:$$F_n=A\\Bigl(\\frac{1+\\sqrt{5}}{2}\\Bigr)^n+B\\Bigl(\\frac{1-\\sqrt{5}}{2}\\Bigr)^n$$ 由于又知道两个特殊值：$f(0)=0;f(1)=1$，带入公式中可求出：$$A=\\frac{1}{\\sqrt{5}}$$$$B=-A=-\\frac{1}{\\sqrt{5}}$$ 带入通项公式，可得：$$F_n=1/\\sqrt{5}{\\Bigl[\\Bigl(\\frac{1+\\sqrt{5}}{2}\\Bigr)^n-\\Bigl(\\frac{1-\\sqrt{5}}{2}\\Bigr)^n\\Bigr]}$$ 代码反而很简单：通项公式123456789 public static int fibonacci(int n) &#123;if(n &lt; 2) return n; double sqrt5=Math.sqrt(5); double fibn=Math.pow((1+sqrt5)/2,n)-Math.pow((1-sqrt5)/2,n); return (int)(fibn/sqrt5); &#125; 时间复杂度：$O(logn)$–Math.pow()方法需要空间复杂度：$O(1)$ 7. 总结 斐波那契数列的六种解法基本如上，后两种方法为了达到$O(logn)$级别的时间复杂度可谓是“不择手段”。多写两句，最近在刷算法题和复习基本的东西，感觉基础的东西确实需要好好看看。之前业务压力太大，甭说博客了，简单的总结时间都没有，睡眠也不太够。趁着最近调整调整，博客也要及时更新了。没有什么事情是很容易的，继续加油吧。","categories":[{"name":"算法","slug":"算法","permalink":"https://ten-z.github.io/categories/算法/"}],"tags":[{"name":"Fibonacci","slug":"Fibonacci","permalink":"https://ten-z.github.io/tags/Fibonacci/"}]},{"title":"一起读RxJava源码（五）——线程调度","slug":"一起读RxJava源码（五）——线程调度","date":"2018-08-01T11:28:14.000Z","updated":"2019-07-01T09:35:04.000Z","comments":true,"path":"2018/08/01/一起读RxJava源码（五）——线程调度/","link":"","permalink":"https://ten-z.github.io/2018/08/01/一起读RxJava源码（五）——线程调度/","excerpt":"经过前面四篇文章，我们已经了解了RxJava相关的一些基础。接下来，我们将进入RxJava最核心的内容—-线程调度。从Rx官网介绍来看，ReactiveX系列实现的核心功能就是异步编程，而程序层面中实现异步的核心是多线程。本篇文章内容稍长，如果稍有困惑可直接跳到文章末尾看流程图，可能会方便理解。","text":"经过前面四篇文章，我们已经了解了RxJava相关的一些基础。接下来，我们将进入RxJava最核心的内容—-线程调度。从Rx官网介绍来看，ReactiveX系列实现的核心功能就是异步编程，而程序层面中实现异步的核心是多线程。本篇文章内容稍长，如果稍有困惑可直接跳到文章末尾看流程图，可能会方便理解。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava 1. 线程调度的核心：Scheduler Scheduler本身就是调度程序、调度器的意思。这里把它称为“核心”是因为RxJava实现线程调度主要方式是将Scheduler作为参数传入相关操作符中实现的，比如一会要讲的SubscribeOn和ObserveOn。而在Rx官网介绍中，Scheduler本身就能实现多线程的相关功能。下面我们一起来看下。 1.1 Scheduler介绍 Scheduler是线程控制器，RxJava通过它来指定每一段代码应该运行在什么样的线程。RxJava已经内置了几个Scheduler，它们已经适合大多数的使用场景： Schedulers.immediate()：直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。 Schedulers.newThread()：总是启用新线程，并在新线程执行操作。 Schedulers.io()：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。 Schedulers.computation()：计算所使用的Scheduler。这个计算指的是CPU密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为CPU核数。不要把I/O操作放在computation()中，否则I/O操作的等待时间会浪费CPU。 AndroidSchedulers.mainThread()：Android专用，它指定的操作将在Android主线程运行。 RxJava最常规的线程控制就是通过这几个Scheduler配合subscribeOn()和observeOn()两个方法来对线程进行控制。 1.2 单独使用Scheduler 除了将Scheduler传递给RxJava运算符之外，我们还可以单独使用Scheduler来安排自己的订阅工作。可以使用RxJava的Scheduler.Worker类实现Java中利用Thread实现的多线程功能：Scheduler实现多线程1234567891011Scheduler.Worker worker = Schedulers.newThread().createWorker();worker.schedule(new Action0() &#123; @Override public void call() &#123; yourWork(); &#125;&#125;);// some time later...worker.unsubscribe(); 在执行worker.schedule时会在新线程中执行call()中的代码。并可以通过worker.unsubscribe()终止线程。 之外，还可以实现延迟执行和周期执行： 延时500ms后执行 1someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS); 延时500ms后，每隔250ms执行一次 1someScheduler.schedulePeriodically(someAction，500,250，TimeUnit.MILLISECONDS); 2. 线程调度的基本实现 上一小节中提到过，RxJava实现线程控制主要是通过Scheduler配合subscribeOn()和observeOn()两个操作符来实现。下面简单介绍下这两个操作符的功能： subscribeOn(): 指定subscribe()所发生的线程，一方面是Observable.OnSubscribe被激活时所处的线程，或者叫做事件产生的线程。另一方面是观察者接收前的所处的线程，或者称为事件下发的线程。observeOn(): 指定Subscriber观察者所运行在的线程。或者叫做事件消费的线程。 定义如果没看太明白的话可以结合接下来的示例，下面是线程调度最基本的实现方式：线程调度基本实现1234567891011121314151617181920212223242526Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;hello rxjava&quot;); subscriber.onCompleted(); &#125;&#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); textView.setText(s); &#125; &#125;); 跟前几篇文章中基本方式比较，仅仅是多了.subscribeOn(Schedulers.io())和.observeOn(AndroidSchedulers.mainThread())两句。 在上面这段代码中，由于在create()后指定了subscribeOn(Schedulers.io())，Observable.OnSubscribe中call回调中的内容会在IO线程执行，即内容为”hello rxjava”的事件会在IO线程发出。而由于在subscribe()之前observeOn(AndroidScheculers.mainThread())的指定，使得Subscriber中给textView赋值的操作（UI的操作）会在主线程中执行。 通过对上面例子的解释可以看出，RxJava切换线程仅仅通过添加subscribeOn和observeOn操作符就能实现，并且可以通过多次调用observeOn实现多次切换线程。 能如此方便的切换线程，简直业界良心啊有木有。对于一名android搬砖工而言，可以不用纠结AsyncTask、线程和handler了。使用RxJava仅仅通过两个操作符就能实现线程间的切换、调度、可控，并大大减少代码量，增加可读性…… 当然，到此仅仅是介绍了RxJava实现线程调度的基本操作，下面我们就来分析分析源码，看看是怎么实现的。 3. 线程调度的源码解析——基于事件流 下面的讲解还是以线程调度的基本实现为例，但是这回我们讲解的顺序不按照绝大部分博客的思路——按代码顺序从上至下的方式进行。因为经过前两篇文章对基础源码的分析，我们发现RxJava在执行到subscribe()才会去产生事件并下发，所以这里我们以事件的产生到接收流程为顺序进行源码逻辑的分析，个人认为会更好理解一点。请再回顾一下刚才线程调度基本实现的代码，找到建立依赖关系的地方。 3.1 observeOn()源码解析（一） 先来分析下在subscribe()方法之前调用的observeOn()。这里是建立关系的开始，也是事件的开始。 先来看下observeOn()源码：observeOn()源码1234567891011121314public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, RxRingBuffer.SIZE);&#125;……public final Observable&lt;T&gt; observeOn(Scheduler scheduler, int bufferSize) &#123; return observeOn(scheduler, false, bufferSize);&#125;……public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return lift(new OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));&#125; 经历了层层调用后我们终于看到了observeOn()核心的东西，它调用了一个lift()方法。在上一篇文章最后我简单的介绍了一下：map原理的本质是lift。来看下lift()的源码:lift()源码123public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) &#123; return unsafeCreate(new OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));&#125; 可以看到和map()是几乎一模一样了，所以和map原理一样，lift本质也是创建了一个新的Observable。跟前面的文章一样，这里记为ObservableC……为什么是C，因为B在下一小节。这个ObservableC传入的OnSubscribe是一个OnSubscribeLift。下面就来看下这个OnSubscribeLift：OnSubscribeLift源码12345678910111213141516171819202122232425262728293031public final class OnSubscribeLift&lt;T, R&gt; implements OnSubscribe&lt;R&gt; &#123; final OnSubscribe&lt;T&gt; parent; final Operator&lt;? extends R, ? super T&gt; operator; public OnSubscribeLift(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? super T&gt; operator) &#123; this.parent = parent; this.operator = operator; &#125; @Override public void call(Subscriber&lt;? super R&gt; o) &#123; try &#123; Subscriber&lt;? super T&gt; st = RxJavaHooks.onObservableLift(operator).call(o); try &#123; // new Subscriber created and being subscribed with so &apos;onStart&apos; it st.onStart(); parent.call(st); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); st.onError(e); &#125; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); o.onError(e); &#125; &#125;&#125; 所以综上，当程序执行到observeOn(AndroidSchedulers.mainThread()).subscribe()，实际本质是在执行ObservableC.subscribe(new SubscriberD)。以后的逻辑就不多说了，相信看了前面两篇文章到这里基础应该十分扎实了。看下ObservableC——OnSubscribeLift的call()方法，RxJavaHooks.onObservableLift(operator)实际上就是将传入的operator返回了。并且调用了operator.call。这里的operator实际上是lift传入的参数OperatorObserveOn。下面来看下OperatorObserveOn.call：OperatorObserveOn的call方法12345678public Subscriber&lt;? super T&gt; call(Subscriber&lt;? super T&gt; child) &#123; ... ObserveOnSubscriber&lt;T&gt; parent = new ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize); parent.init(); return parent; &#125; 也是跟map一样，初始化了一个SubscriberC——ObserveOnSubscriber并调用init进行了初始化。下一步，回到OnSubscribeLift.Call中继续执行parent.call(st),也是就是调用了前一级Observable对应OnSubscriber.call(st)。注意这里和map有一点形式上的不一样，说是形式上是因为map这里是这样的：source.unsafeSubscribe(parent)，形式上是将上一级的Observable和本级的MapSubscriber建立了观察依赖，但实际起作用的其实是建立依赖后调用上一级的Observable的OnSubscriber.call,这里和observeOn()其实本质又一样了。因此，这里也可以看成执行了下面一句：1ObservableB.subscribe(SubscriberC) 于是，根据基本调用逻辑，事件又往上一级ObservableB去了。 3.2 subscribeOn()源码解析（一） 在线程调度的基本实现的例子中，在observeOn()方法之前调用的就是subscribeOn(Schedulers.io())，所以这一小节，我们来看下subscribeOn()的源码。subscribeOn()源码1123public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; return subscribeOn(scheduler, !(this.onSubscribe instanceof OnSubscribeCreate));&#125; subscribeOn()调用了一个两个参数的subscribeOn方法，我们继续：subscribeOn()源码2123456public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler, boolean requestOn) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return unsafeCreate(new OperatorSubscribeOn&lt;T&gt;(this, scheduler, requestOn));&#125; 重点在最后一句，如果你看了上一篇map()的源码解析，应该有印象：unsafeCreate()方法会创建一个新的被观察者Observable。由此可以预见，subscribeOn()的执行流程应该和map()差不多。这里会创建一个新的被观察者，记为ObservableB。传入的对应的OnSubscribe就是OperatorSubscribeOn。OperatorSubscribeOn源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public final class OperatorSubscribeOn&lt;T&gt; implements OnSubscribe&lt;T&gt; &#123; final Scheduler scheduler; final Observable&lt;T&gt; source; final boolean requestOn; public OperatorSubscribeOn(Observable&lt;T&gt; source, Scheduler scheduler, boolean requestOn) &#123; this.scheduler = scheduler; this.source = source; this.requestOn = requestOn; &#125; @Override public void call(final Subscriber&lt;? super T&gt; subscriber) &#123; final Worker inner = scheduler.createWorker(); SubscribeOnSubscriber&lt;T&gt; parent = new SubscribeOnSubscriber&lt;T&gt;(subscriber, requestOn, inner, source); subscriber.add(parent); subscriber.add(inner); inner.schedule(parent); &#125; static final class SubscribeOnSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; implements Action0 &#123; final Subscriber&lt;? super T&gt; actual; final boolean requestOn; final Worker worker; Observable&lt;T&gt; source; Thread t; SubscribeOnSubscriber(Subscriber&lt;? super T&gt; actual, boolean requestOn, Worker worker, Observable&lt;T&gt; source) &#123; this.actual = actual; this.requestOn = requestOn; this.worker = worker; this.source = source; &#125; @Override public void onNext(T t) &#123; actual.onNext(t); &#125; @Override public void onError(Throwable e) &#123; try &#123; actual.onError(e); &#125; finally &#123; worker.unsubscribe(); &#125; &#125; @Override public void onCompleted() &#123; try &#123; actual.onCompleted(); &#125; finally &#123; worker.unsubscribe(); &#125; &#125; @Override public void call() &#123; Observable&lt;T&gt; src = source; source = null; t = Thread.currentThread(); src.unsafeSubscribe(this); &#125; @Override public void setProducer(final Producer p) &#123; actual.setProducer(new Producer() &#123; @Override public void request(final long n) &#123; if (t == Thread.currentThread() || !requestOn) &#123; p.request(n); &#125; else &#123; worker.schedule(new Action0() &#123; @Override public void call() &#123; p.request(n); &#125; &#125;); &#125; &#125; &#125;); &#125; &#125;&#125; 通过上一小节我们知道事件经过observeOn后，会先调用ObservableB的OnSubscribe的call方法，这里即为OperatorSubscribeOn的call方法。 先简单过一下OperatorSubscribeOn的call中的代码的大概流程：首先通过scheduler.createWorker()构建了一个Worker；然后用传进来的subscriber构造了一个新的SubscribeOnSubscriber，记为subscriberB，并将subscriberB丢到Worker.schedule()创建的新线程来处理；新线程中，Worker.schedule(subscriberB)会执行subscriberB中的call方法，在call中会用上一级Observable去订阅观察者subscriberB，即ObservableA.subscribe(subscriberB)。提炼一下：切换线程，添加订阅ObservableA.subscribe(subscriberB)。 下面是详细的解析：第一步：final Worker inner = scheduler.createWorker(); 从上面的流程来看，这个Worker就是线程调度的关键，从前面1.2中的例子也能看出来，Worker本身就是用来创建新线程的。而在这个例子中，创建Worker的scheduler往上回溯去查找发现就是subscribeOn(Schedulers.io())中的Schedulers.io()，就是通过它创建了我们前面提到的Worker。所以下面来看看Schedulers.io()的实现：Schedulers.io()源码123public static Scheduler io() &#123; return RxJavaHooks.onIOScheduler(getInstance().ioScheduler);&#125; RxJavaHooks.onIOScheduler和绝大多数RxJavaHooks里的方法一样，把传入的scheduler返回了。这里的scheduler传入了一个getInstance().ioScheduler，看来是一个单例类，去它的私有构造器中找到ioScheduler的初始化：ioScheduler的初始化1234567891011private Schedulers() &#123; ... Scheduler io = hook.getIOScheduler(); if (io != null) &#123; ioScheduler = io; &#125; else &#123; ioScheduler = RxJavaSchedulersHook.createIoScheduler(); &#125; ... &#125; 继续看RxJavaSchedulersHook.createIoScheduler()：createIoScheduler()源码12345678910public static Scheduler createIoScheduler() &#123; return createIoScheduler(new RxThreadFactory(&quot;RxIoScheduler-&quot;));&#125;public static Scheduler createIoScheduler(ThreadFactory threadFactory) &#123; if (threadFactory == null) &#123; throw new NullPointerException(&quot;threadFactory == null&quot;); &#125; return new CachedThreadScheduler(threadFactory);&#125; 可以看到返回了一个CachedThreadScheduler。也就是说subscribeOn(Schedulers.io())中传入的scheduler实际是这个CachedThreadScheduler。Worker也是CachedThreadScheduler的createWorker()方法创建的：createWorker()源码1234@Overridepublic Worker createWorker() &#123; return new EventLoopWorker(pool.get());&#125; 这里返回了EventLoopWorker，OperatorSubscribeOn的call中第一句话的inner引用持有的Worker。用了这么长的篇幅终于把第一句解析完了，可见理解线程调度还是有一定难度的。下面的工作应该就是根据Worker创建线程了。 第二步：SubscribeOnSubscriber parent = new SubscribeOnSubscriber(subscriber, requestOn, inner, source); 继续到OperatorSubscribeOn源码解析上来。第二步就是普通的基本调用的套路：创建出subscriberB。具体就不解释了，可以参考map的讲解来看。 第三步：inner.schedule(parent); 第一步我们知道inner引用的对象实际是EventLoopWorker，来看下EventLoopWorker的schedule方法：EventLoopWorker的schedule源码12345678910111213141516171819202122@Override public Subscription schedule(Action0 action) &#123; return schedule(action, 0, null); &#125; @Override public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) &#123; ... ScheduledAction s = threadWorker.scheduleActual(new Action0() &#123; @Override public void call() &#123; if (isUnsubscribed()) &#123; return; &#125; action.call(); &#125; &#125;, delayTime, unit); innerSubscription.add(s); s.addParent(innerSubscription); return s; &#125;&#125; 看到它调用了ThreadWorker的scheduleActual()方法。这里的ThreadWorker引用的对象是NewThreadWorker，下面是它的scheduleActual():NewThreadWorker的scheduleActual()源码12345678910111213public ScheduledAction scheduleActual(final Action0 action, long delayTime, TimeUnit unit) &#123; Action0 decoratedAction = RxJavaHooks.onScheduledAction(action); ScheduledAction run = new ScheduledAction(decoratedAction); Future&lt;?&gt; f; if (delayTime &lt;= 0) &#123; f = executor.submit(run); &#125; else &#123; f = executor.schedule(run, delayTime, unit); &#125; run.add(f); return run;&#125; scheduleActual()中的ScheduledAction实现了Runnable接口，通过线程池executor切换了线程。顺便一提，可以在NewThreadWorker构造器中找到executor的初始化：NewThreadWorker源码123456789public NewThreadWorker(ThreadFactory threadFactory) &#123; ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, threadFactory); boolean cancelSupported = tryEnableCancelPolicy(exec); if (!cancelSupported &amp;&amp; exec instanceof ScheduledThreadPoolExecutor) &#123; registerExecutor((ScheduledThreadPoolExecutor)exec); &#125; executor = exec;&#125; 可以看到这里是一个容量为1的newScheduledThreadPool。 这里多说一句，这里只是说明NewThreadWorker是容量为1的newScheduledThreadPool。Schedulers.io()——也就是CachedThreadScheduler(threadFactory)，这个类维护了一个AtomicReference pool集合，集合中的每个元素都是一个NewThreadWorker。可以理解为线程池的缓存。 再回到EventLoopWorker的schedule方法中，我们知道threadWorker.scheduleActual启动了一个新的线程，线程会执行scheduleActual第一个参数——Action0的call方法。而这个call方法中执行了一行：action.call(); 往上层代码中查找发现这里的action就是subscriberB——SubscribeOnSubscriber。因此在SubscribeOnSubscriber代码中可以看到除了OnNext等方法之外还有一个call方法，而正常的subscriber是不应该有call方法的。这个call方法也是因为SubscribeOnSubscriber实现了Action0接口复写的。所以在action.call()中调用的就是SubscribeOnSubscriber里的call。具体代码请自行往上翻…… 在这个call中执行了src.unsafeSubscribe(this)。是的，就是ObservableA.subscribe(subscriberB)。 而ObservableA其实就是Observable.create()，也就是我们自己定义的被观察者。根据基本调用，会执行ObservableA中OnSubscribe的call方法，接着执行subscriberB.onNext(“hello rxjava”)。 所以，subscribeOn是先切换了线程，再去启动事件的，并且从启动事件开始，直到再次切换线程以前，都是在这个新线程中执行的。 下一步，来看下subscriberB——SubscribeOnSubscriber如何接收的。 3.3 subscribeOn()源码解析（二） 来看下subscribeOn()中创建的SubscribeOnSubscriber中接收事件的onNext方法：SubscribeOnSubscriber的onNext源码1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 好惊喜有木有，就TM一句啊……这里actual是OperatorSubscribeOn中call方法带入的，也就是subscriberC——在ObservableB.subscribe(SubscriberC)的时候传入的。 所以这里事件没有操作直接传往SubscriberC的onNext了……这甩锅甩的够快的…… 下面该进入SubscriberC的onNext了。 3.3 observeOn()源码解析（二） SubscriberC是在observeOn()中初始化的ObserveOnSubscriber，来看下源码：ObserveOnSubscriber源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static final class ObserveOnSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; implements Action0 &#123; …… @Override public void onNext(final T t) &#123; if (isUnsubscribed() || finished) &#123; return; &#125; if (!queue.offer(NotificationLite.next(t))) &#123; onError(new MissingBackpressureException()); return; &#125; schedule(); &#125; protected void schedule() &#123; if (counter.getAndIncrement() == 0) &#123; recursiveScheduler.schedule(this); &#125; &#125; // only execute this from schedule() @Override public void call() &#123; long missed = 1L; long currentEmission = emitted; final Queue&lt;Object&gt; q = this.queue; final Subscriber&lt;? super T&gt; localChild = this.child; for (;;) &#123; long requestAmount = requested.get(); while (requestAmount != currentEmission) &#123; boolean done = finished; Object v = q.poll(); boolean empty = v == null; if (checkTerminated(done, empty, localChild, q)) &#123; return; &#125; if (empty) &#123; break; &#125; localChild.onNext(NotificationLite.&lt;T&gt;getValue(v)); currentEmission++; if (currentEmission == limit) &#123; requestAmount = BackpressureUtils.produced(requested, currentEmission); request(currentEmission); currentEmission = 0L; &#125; &#125; if (requestAmount == currentEmission) &#123; if (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123; return; &#125; &#125; emitted = currentEmission; missed = counter.addAndGet(-missed); if (missed == 0L) &#123; break; &#125; &#125; &#125; &#125; 在ObserveOnSubscriber中执行了schedule()，而schedule()中执行了recursiveScheduler.schedule(this)。 来看下recursiveScheduler，在ObserveOnSubscriber构造器中有这么一句：this.recursiveScheduler = scheduler.createWorker(); 看到熟悉的createWorker()以及recursiveScheduler.schedule就知道这里要切换线程了。我们先等等，先看看这个scheduler引用的是啥。一层一层往上查找，发现就是observeOn(AndroidSchedulers.mainThread())传的AndroidSchedulers.mainThread()。再来看下这个方法：ObserveOnSubscriber源码123456789101112131415private AndroidSchedulers() &#123; RxAndroidSchedulersHook hook = RxAndroidPlugins.getInstance().getSchedulersHook(); Scheduler main = hook.getMainThreadScheduler(); if (main != null) &#123; mainThreadScheduler = main; &#125; else &#123; mainThreadScheduler = new LooperScheduler(Looper.getMainLooper()); &#125;&#125;/** A &#123;@link Scheduler&#125; which executes actions on the Android UI thread. */public static Scheduler mainThread() &#123; return getInstance().mainThreadScheduler;&#125; 所以执行scheduler.createWorker()的是LooperScheduler，而这个LooperScheduler(Looper.getMainLooper())传的参数是不是很熟悉？Looper.getMainLooper()获取主线程的Looper。 这里回到ObserveOnSubscriber中来，recursiveScheduler.schedule(this)切换到了主线程并执行this——也就是ObserveOnSubscriber的call方法。call方法中有两句localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));和checkTerminated(done, empty, localChild, q)：就是调用SubscriberD的onNext()、onCompleted()、onError()。 也就是说，observeOn是在之前的线程中接受事件，然后切换线程，这个例子是切换到主线程，然后在新线程（主线程）中下发事件给下一级的观察者。 到这里，线程调度的主要代码就介绍完了，下面看下整体流程。 4. 线程调度整体流程 请回忆线程调度基本实现代码，然后再来看下面的流程。 第一步：Observable.create，创建被观察者，记为ObservableA第二步：.subscribeOn(Schedulers.io())，创建新被观察者，记为ObservableB第三步：.observeOn(AndroidSchedulers.mainThread())，创建新被观察者，记为ObservableC第四步：.subscribe(new Subscriber())，创建观察者，记为SubscriberD，并建立依赖关系：ObservableC.subscribe(SubscriberD) 第五步：创建新观察者ObserveOnSubscriber，记为SubscriberC。并建立新依赖关系ObservableB.subscribe(SubscriberC)第六步：通过制定Scheduler创建Worker；创建新观察者SubscribeOnSubscriber，记为SubscriberB；worker.schedule()切换新线程；在新线程中执行ObservableA.subscribe(SubscriberB) 第七步：ObservableA中OnSubscribe的call开始发送事件”hello rxjava” 第八步：SubscriberB接到事件后，直接甩给SubscriberC第九步：SubscriberC接收事件；通过Worker切换到主线程；在主线程中将事件传递给SubscriberD第十步：SubscriberD接收事件，整体流程结束 根据流程我们可以简单总结为：subscribeOn在事件上行时切换线程，而observeOn是在事件下发时切换线程。自己画了张图，加深理解： 5. 总结 线程调度到这里就告一段落了，我讲的也是寥寥数语，只是把大体流程介绍了一遍。如果想仔细搞懂每一步的细节，还需要在多线程以及handler机制上下功夫。 我们经过这几篇的介绍,RxJava源码主要的逻辑基本介绍完了。下一章会介绍一些较为轻松的RxJava的具体应用，敬请期待！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（四）——转换操作符","slug":"一起读RxJava源码（四）——转换操作符","date":"2018-06-24T09:20:25.000Z","updated":"2019-07-01T09:34:52.000Z","comments":true,"path":"2018/06/24/一起读RxJava源码（四）——转换操作符/","link":"","permalink":"https://ten-z.github.io/2018/06/24/一起读RxJava源码（四）——转换操作符/","excerpt":"上一篇我们介绍了RxJava最基本的实现方式以及源码逻辑，但是仅仅会基础实现方式是远远不够的。RxJava有着大量的各式各样的操作符（如上图谱所示）。也正是因为这些操作符，使得RxJava可以很简单且简洁的实现一些复杂的问题。这也是RxJava以至于Rx系列强大的原因之一。","text":"上一篇我们介绍了RxJava最基本的实现方式以及源码逻辑，但是仅仅会基础实现方式是远远不够的。RxJava有着大量的各式各样的操作符（如上图谱所示）。也正是因为这些操作符，使得RxJava可以很简单且简洁的实现一些复杂的问题。这也是RxJava以至于Rx系列强大的原因之一。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava 1. 前言 上一篇我们介绍的RxJava最基本的实现方式虽然没有展现出RxJava的强大，但是却是一切的基础。没有看过的工友建议先看下，以免这一章节消化不了。 RxJava的操作符有很多，上面的图谱里就能看出来，具体使用可以参考官网介绍。这里主要介绍的是转换操作符，它作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。直接看概念可能会不太好理解，这篇文章以相对简单且常用的转换操作符map为例，进行源码的分析。了解map操作符的逻辑之后可能再来看概念就容易理解得多了。 转换操作符实现的其实是“变换”的原理。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 ——转换操作符原理 2. map操作符的简单应用 先举个例子，将一组字符串中的小写字符转换成大写输出，用map可以这样实现：map实现字符串中小写转大写12345678910111213141516171819202122232425262728List&lt;String&gt; froms = new ArrayList&lt;&gt;();froms.add(&quot;hello&quot;);froms.add(&quot;rxjava&quot;);froms.add(&quot;毁我青春&quot;);Observable.from(froms) .map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.toUpperCase(); &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; //System.out.println(&quot;onCompleted&quot;); Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); &#125; &#125;); 输出的结果是这样的：输出结果1234onNext=HELLOonNext=RXJAVAonNext=毁我青春onCompleted 这里Observable.from()这个方法是将传入的数组或Iterable拆分成具体对象后，依次发送出来。和之前的之前的create(OnSubscribe)是等价的。 可以看到，map()方法将每次接收到的String对象进行了toUpperCase()操作，经过map()方法后，Subscriber里onNext()收到的就是转换成大写的内容。当然，map()方法也可以进行其他类型的转换，比如将int转换成字符串，或是字符串转换成Bitmap对象等，在Func1类构造函数的泛型参数(new Func1&lt;String, String&gt;())就是转换前和转换后的对象类型。 总结一下map()的用法：它是对事件对象一对一的直接变换，也是RxJava最常用的变换。如下图所示： 3. map操作符的源码解析为了基于上一章节所讲的内容，我们把上面的例子变得简单一点：RxJava基本实现+map123456789101112131415161718192021222324252627Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;hello rxjava&quot;); subscriber.onCompleted(); &#125;&#125;).map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.toUpperCase(); &#125;&#125;).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(&quot;tag&quot;, &quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(&quot;tag&quot;, &quot;onNext=&quot; + s); &#125;&#125;); 由于上一章节讲解了Observable.create()和.subscribe()的源码，所以这里用了上一章节介绍的RxJava基本实现。from()的源码解析这里就不多赘述了，主要还是理解map的基本的逻辑。 这里Observable.create()自然不必多说，最终返回了一个新创建的被观察者Observable。下一步会执行Observable.map()。 map()的源码也在Observable类里：map()源码123public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) &#123; return unsafeCreate(new OnSubscribeMap&lt;T, R&gt;(this, func));&#125; 再看下unsafeCreate()的类：unsafeCreate()源码123public static &lt;T&gt; Observable&lt;T&gt; unsafeCreate(OnSubscribe&lt;T&gt; f) &#123; return new Observable&lt;T&gt;(RxJavaHooks.onCreate(f));&#125; 是不是有点眼熟？？因为跟Observable.create()的实现是一毛一样的啊！可以现在回到上一章节对比一下。也就是说，map()方法也是直接返回了一个新创建的被观察者Observable，这是一个新的被观察者，我们把它称为ObservableB；一开始通过Observable.create()创建的Observable我们称之为ObservableA。 我们可以看到在ObservableB中，传入RxJavaHooks.onCreate(f)的参数可以追溯到map()方法里传入的new OnSubscribeMap(this, func)。所以，ObservableB对应的OnSubscribe就是这个OnSubscribeMap。而ObservableA和变换函数Func1则作为构造OnSubscribeMap的参数。 现在我们现在把视野拉远，从整体再看下这个例子的逻辑： 也就是说，在执行了map方法后，变成了ObservableB和Subscriber建立订阅关系。我们把最后的观察者也起个名子区分，叫SubscriberC。总结下，就是原本ObservableA.subscribe(SubscriberC)之间加了.map()后，现在变成了ObservableB.subscribe(SubscriberC)。 根据上一篇文章介绍的RxJava基础流程，在ObservableB.subscribe(SubscriberC)建立订阅关系后，应该执行ObservableB的onSubscribe里的call方法。上面讲到了 ObservableB对应的OnSubscribe是OnSubscribeMap，我们来看一下OnSubscribeMap的源码： OnSubscribeMap源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public final class OnSubscribeMap&lt;T, R&gt; implements OnSubscribe&lt;R&gt; &#123; final Observable&lt;T&gt; source; final Func1&lt;? super T, ? extends R&gt; transformer; public OnSubscribeMap(Observable&lt;T&gt; source, Func1&lt;? super T, ? extends R&gt; transformer) &#123; this.source = source; this.transformer = transformer; &#125; @Override public void call(final Subscriber&lt;? super R&gt; o) &#123; MapSubscriber&lt;T, R&gt; parent = new MapSubscriber&lt;T, R&gt;(o, transformer); o.add(parent); source.unsafeSubscribe(parent); &#125; static final class MapSubscriber&lt;T, R&gt; extends Subscriber&lt;T&gt; &#123; final Subscriber&lt;? super R&gt; actual; final Func1&lt;? super T, ? extends R&gt; mapper; boolean done; public MapSubscriber(Subscriber&lt;? super R&gt; actual, Func1&lt;? super T, ? extends R&gt; mapper) &#123; this.actual = actual; this.mapper = mapper; &#125; @Override public void onNext(T t) &#123; R result; try &#123; result = mapper.call(t); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); unsubscribe(); onError(OnErrorThrowable.addValueAsLastCause(ex, t)); return; &#125; actual.onNext(result); &#125; @Override public void onError(Throwable e) &#123; if (done) &#123; RxJavaHooks.onError(e); return; &#125; done = true; actual.onError(e); &#125; @Override public void onCompleted() &#123; if (done) &#123; return; &#125; actual.onCompleted(); &#125; @Override public void setProducer(Producer p) &#123; actual.setProducer(p); &#125; &#125;&#125; OnSubscribeMap实现了OnSubscribe接口，因此OnSubscribeMap就是一个OnSubscribe。我们来看下OnSubscribeMap的call方法。首先通过我们的观察者o(即SubscriberC)和转换函数transformer构造了一个MapSubscriber。然后调用了source的unsafeSubscribe(）。 我们看下这个source是从OnSubscribeMap(Observable&lt;T&gt; source, Func1&lt;? super T, ? extends R&gt; transformer)这个构造器里传过来的。往上一级看，这个构造器是在ObservableA.map()方法里调用的（具体源码请往上翻到map()源码），这里source传入的就是ObservableA。 所以这里小结下，OnSubscribeMap的call方法里本质是调用了ObservableA的unsafeSubscribe()。我们继续深入，看下unsafeSubscribe()源码： unsafeSubscribe()源码12345678910111213141516171819202122232425public final Subscription unsafeSubscribe(Subscriber&lt;? super T&gt; subscriber) &#123; try &#123; subscriber.onStart(); RxJavaHooks.onObservableStart(this, onSubscribe).call(subscriber); return RxJavaHooks.onObservableReturn(subscriber); &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); try &#123; subscriber.onError(RxJavaHooks.onObservableError(e)); &#125; catch (Throwable e2) &#123; Exceptions.throwIfFatal(e2); RuntimeException r = new OnErrorFailedException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2); RxJavaHooks.onObservableError(r); throw r; // NOPMD &#125; return Subscriptions.unsubscribed(); &#125;&#125; 有没有很眼熟？？可以返回上一篇文章里.subscribe()源码解析看一下，是的，你应该没有记错，这段代码跟.subscribe()的源码基本完全一样。核心的那句又出来了：1RxJavaHooks.onObservableStart(observable,observable.onSubscribe).call(subscriber); 也就是说，调用了ObservableA的onSubscribe里的call方法，也就是执行了ObservableA.subscribe(MapSubscriber)。而MapSubscriber其实是在OnSubscribeMap.call()中new出来的。可以理解成是属于B的。执行到这里B不再只是SubscriberC的被观察者了，他同时也是ObservableA的观察者，记为 SubscriberB。B = (ObservableB+SubscriberB)。 所以到这里，我们可以这样理解： 第一步：ObservableB.subscribe(SubscriberC)第二步：调用ObservableB的call方法第三步：在ObservableB的call方法里创建了SubscriberB ，并调用了ObservableA.subscribe(SubscriberB) 下一步跟之前以及RxJava基本调用逻辑一样，执行ObservableA的onSubscribe里的call方法。就是执行基本源码的这两句：ObservableA的onSubscribe12subscriber.onNext(&quot;hello rxjava&quot;);subscriber.onCompleted(); 也是根据上一章讲的RxJava基本调用（所以基本调用的逻辑很重要啊），这里事件开始下发了。下一步会执行ObservableA.subscribe(SubscriberB)中SubscriberB的onNext()和onCompleted()，也就是MapSubscriber。 MapSubscriber的源码在刚才的OnSubscribeMap里，它的onNext()里主要执行就下面两句：MapSubscriber的onNext()12result = mapper.call(t);actual.onNext(result); 这里mapper就是变换函数，通过MapSubscriber构造器向上找，发现就是OnSubscribeMap的 transformer，这个transformer也是OnSubscribeMap构造器传入的。再往上看，豁然开朗：就是map()里传的Func1，mapper.call也就是执行我们.map()里自己写的回调：mapper123456.map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.toUpperCase(); &#125;&#125;) 这里其实就是实现我们自己定义的变换了。我们定义的变换函数将String中的所有小写转换成了大写。下一步会执行actual.onNext(result)，这里就不再一层层的找了，这个actual其实就是o(即SubscriberC)。在SubscriberC的 onNext中我们输出了接收到的result，也就是变换过后的String。 同样在调用MapSubscriber.onCompleted()时会执行subscriberOne.onCompleted()。这样就完成了一整套的调用流程。 终于到最后总结了，想把转换说明白还是挺费劲的。前面没看懂的话可以看下下面总结出的调用逻辑（整合了基本调用的逻辑）： 第一步：创建ObservableA第二步：在调用.map()时创建ObservableB第三步：执行ObservableB.subscribe(SubscriberC)第四步：调用ObservableB的call方法第五步：在ObservableB的call方法里创建了SubscriberB，并调用了ObservableA.subscribe(SubscriberB)第六步：调用ObservableA里onSubscribe里的call，事件从A开始下发第七步：SubscriberB的onNext接收事件，并调用map()里的转换方法，事件继续下发第八步：SubscriberC的onNext接收转换后的事件。 至此，从被观察者A到观察者C的事件流就完成了。中间的转换可以简单理解成经历了一个B,B对A和C分别建立了观察和被观察的关系。在B中实现了事件流的转换。从A和C的一层订阅变成了ABC的两层订阅。 看下扔物线大神的这张图可能会更好理解我所说的两层订阅： 张磊大神的这张图则可以很清楚的理解调用逻辑： 4. 总结 到这里，map()转换原理就讲解完了，其实map()的原理本质是lift()。只不过map()这个操作符举例比较容易，逻辑也相对简单。有兴趣的工友可以看下扔物线大神的《给 Android 开发者的 RxJava 详解》里对lift()原理的解释，你会发现和map()实现是一样的。 下一章节，会基于这个变换原理，来讲解线程调度的源码分析，调用逻辑和map很相似。建议大家先把转换原理搞明白。大家加油！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（三）——RxJava的基本实现","slug":"一起读RxJava源码（三）——RxJava的基本实现","date":"2018-06-08T11:39:16.000Z","updated":"2019-07-01T09:34:46.000Z","comments":true,"path":"2018/06/08/一起读RxJava源码（三）——RxJava的基本实现/","link":"","permalink":"https://ten-z.github.io/2018/06/08/一起读RxJava源码（三）——RxJava的基本实现/","excerpt":"前两篇我们介绍了RxJava的一些基本概念，以及通过源码了解了观察者模式这一基础知识。从这一章开始，我们将依次由浅入深的了解RxJava的主要操作以及源码的实现。","text":"前两篇我们介绍了RxJava的一些基本概念，以及通过源码了解了观察者模式这一基础知识。从这一章开始，我们将依次由浅入深的了解RxJava的主要操作以及源码的实现。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava 1. 前言 在上一章节最开始我们提到过：RxJava的异步实现，是通过一种扩展的观察者模式来实现的。上一章节介绍了基础的观察者模式，这一章节我们一起来看一下RxJava是如何实现扩展的观察者模式的。 2. 扩展的观察者模式2.1 RxJava的四个基本概念Observable(可观察者，即被观察者)Observer/Subscriber(观察者)Subscribe(订阅)事件（相当于观察者模式中被观察者用来通知观察者的notifyObservers()方法，类似分发的事件） 2.2 工作原理 Observable和Observer/Subscriber通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件来通知Observer/Subscriber。 特别注意的是，与传统观察者模式不同，RxJava的Observer/Subscriber回调方法除了普通事件onNext()（相当于update）之外，还定义了两个特殊的事件：onCompleted()和onError()。 onCompleted()：事件队列完结。RxJava不仅把每个事件单独处理，还会把它们看做一个队列。RxJava规定，当不会再有新的onNext()发出时，需要触发onCompleted()方法作为标志。 onError()：事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中，onCompleted()和onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted()和onError()二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 RxJava的扩展的观察者模式大致如下图： 3. RxJava的基本实现使用RxJava的基本实现操作拢共分三步：第一步：初始化 Observable第二步：初始化 Observer第三步：建立订阅关系 基本调用完整起来是这样的： 请务必记住这个基本实现，在后面的源码讲解中还会回到这个基本实现代码上来。我会用“RxJava基本实现”加粗的方式表示需要回到这里看下面的基本实现代码，以便更好的理解源码。 RxJava基本实现1234567891011121314151617181920212223Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;垃圾软件，毁我青春&quot;); subscriber.onCompleted(); &#125;&#125;).subscribe(new Subscriber() &#123; @Override public void onCompleted() &#123; //System.out.println(&quot;onCompleted:&quot;); Log.d(&quot;tag&quot;, &quot;onCompleted:&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.d(&quot;tag&quot;, &quot;onNext:&quot; + ((String)o).toString()); &#125;&#125;); 和上一小节讲得工作原理一样，首先调用Observable.create()创建一个被观察者Observable，同时创建一个OnSubscribe作为create()方法的入参；接着创建一个观察者Subscriber，然后通过subseribe()实现二者的订阅关系。 下面就是对这三步进行源码的分析，看看他们都干了什么。 3.1 Observable.create()源码解析在上面的基本调用示例中，Observable.create()使用是这样的：Observable.create()源码解析1234567Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;垃圾软件，毁我青春&quot;); subscriber.onCompleted(); &#125;&#125;) 看下Observable.create()这个方法的源码Observable.create()源码123public static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) &#123; return new Observable&lt;T&gt;(RxJavaHooks.onCreate(f));&#125; 在执行Observable.create()的时候，直接返回了一个新创建的被观察者Observable。同时将RxJavaHooks.onCreate(f)作为构造函数的参数。进一步看一下Observable的构造函数：Observable构造函数123protected Observable(OnSubscribe&lt;T&gt; f) &#123; this.onSubscribe = f;&#125; 可以发现这里构造函数只是将传入的RxJavaHooks.onCreate(f)参数赋值给了Observable类里的onSubscribe引用，构造函数就结束了。我们从RxJava基本实现代码中看到RxJavaHooks.onCreate(f)里的f是Observable.create里那个新创建的onSubscribe。那么下一步看看传入的参数RxJavaHooks.onCreate(f)做了什么。RxJavaHooks.onCreate(f)源码1234567public static &lt;T&gt; Observable.OnSubscribe&lt;T&gt; onCreate(Observable.OnSubscribe&lt;T&gt; onSubscribe) &#123; Func1&lt;Observable.OnSubscribe, Observable.OnSubscribe&gt; f = onObservableCreate; if (f != null) &#123; return f.call(onSubscribe); &#125; return onSubscribe;&#125; 由于我们并没调用RxJavaHooks.initCreate()，所以上面代码中的onObservableCreate为null；于是代码会跳过if语句里的内容，继续执行下面的内容。因此RxJavaHooks.onCreate(f)最终返回的就是f，也就是我们在Observable.create()的时候new出来的OnSubscribe。 在这个基本的例子里，似乎RxJavaHooks.onCreate(f)有点多余，因为对传入的f直接返回了，还多了一层调用。不过，因为这个例子里我们的onObservableCreate为null，如果不为null，执行OnSubscribe的call回调(f.call)，其实是直接通知事件了，因为在OnSubscribe的call方法里一般会执行subscriber.onNext()，后面我们会看到类似的效果。 3.2 subscribe()源码解析 在示例代码RxJava基本实现中，执行完Observable.create()方法之后，返回了一个Observable，下一步会执行.subscribe()方法(Observable.subscribe())，相当于如下代码（这里的Observable是Observable.create()返回的）类比代码12345678910111213141516Observable.subscribe(new Subscriber() &#123; @Override public void onCompleted() &#123; Log.d(&quot;tag&quot;, &quot;onCompleted:&quot;); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.d(&quot;tag&quot;, &quot;onNext:&quot; + ((String)o).toString()); &#125;&#125;); 我们可以看到，在.subscribe()方法里传入个一个新创建的观察者Subscriber()。Subscriber()是实现Observer接口的一个抽象类，在初始化Subscriber()的时候实现了Observer接口的三个回调方法：onNext(),onCompleted(),onError()。 下面来看下.subscribe()里做了些什么。.subscribe()源码解析12345678910111213141516171819202122232425public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) &#123; return Observable.subscribe(subscriber, this);&#125;static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) &#123; …… // new Subscriber so onStart it subscriber.onStart(); if (!(subscriber instanceof SafeSubscriber)) &#123; subscriber = new SafeSubscriber&lt;T&gt;(subscriber); &#125; try &#123; // allow the hook to intercept and/or decorate RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber); return RxJavaHooks.onObservableReturn(subscriber); &#125; catch (Throwable e) &#123; …… &#125; return Subscriptions.unsubscribed(); &#125;&#125; 看上去有点唬人，我里删减了下。最核心的其实是这句1RxJavaHooks.onObservableStart(observable,observable.onSubscribe).call(subscriber); 这里RxJavaHooks和之前提到的一样，返回的是第二个入参observable.onSubscribe，也就是RxJava基本实现中observable.create()里初始化的onSubscribe。 所以这段代码可以看成：1onSubscribe.call(subscriber) 这里可以看到，onSubscribe里的call被调用了，这意味着事件发送的逻辑开始运行。因此在RxJava中，Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候。 我们继续看onSubscribe.call(subscriber)的执行情况。在RxJava基本实现中onSubscribe在它的call方法实现里执行了如下两行代码：onSubscribe的call回调12subscriber.onNext(&quot;垃圾软件，毁我青春&quot;);subscriber.onCompleted(); 于是，接下来会将参数传给subscribe()方法里Subscriber对象的onNext()，onNext()接收参数并输出日志。然后执行subscriber的onCompleted()，原理同上。 最后，RxJava基本实现就完成了，结果如下图： 4. 总结 简单总结一下RxJava基本实现的调用逻辑： 初始化被观察者Observable 初始化观察者Subscriber 通过subscribe()建立订阅关系，并立即发送事件 执行onSubscribe里的call回调，发送事件 观察者Subscriber的相应回调接收事件参数，执行各自逻辑 至此，我们把RxJava的基本实现顺着源码的逻辑捋了一篇，这里用张磊大神的一张图来说明具体调用的逻辑： 我们发现RxJava首先是实现了一个订阅的形式，将观察者和被观察者解耦，这里和普通观察者还是很像的。同时，我们也发现Rxjava一但执行了订阅方法subscribe()就会立刻发送事件，它没有像普通观察者内部Vector的存储机制，也就无法解决一对多依赖的问题。 下一章节，我们会一起学习RxJava基本操作符–主要是变换操作符的一些源码和逻辑。在此之前，建议先把基础的逻辑看懂。加油！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（二）——基础知识:观察者模式","slug":"一起读RxJava源码（二）——基础知识-观察者模式","date":"2018-05-27T07:49:06.000Z","updated":"2023-07-05T08:20:32.474Z","comments":true,"path":"2018/05/27/一起读RxJava源码（二）——基础知识-观察者模式/","link":"","permalink":"https://ten-z.github.io/2018/05/27/一起读RxJava源码（二）——基础知识-观察者模式/","excerpt":"不知不觉博客搭建完成已经一个多月了，至今磕磕绊绊才发了两篇。搭建自己的博客之前看过不少别人搭建的技术博客，隐约发现一个有意思的规律，似乎每个博客的开始段落都会放一张跟技术毫不相干的照片，比如风景照，明星，篮球，动漫等等。我看过的绝大多数技术博客都完美的符合这一规律，原因不详，不明觉厉。平常倒是见过很多餐厅里挂关公、宿舍里挂科比柯南的，不知道是不是同一个道理，emmm……そですね。 所以自己写博客的时候觉得也遵守一下规律，求以后写博客文思泉涌，周末不加班……。","text":"不知不觉博客搭建完成已经一个多月了，至今磕磕绊绊才发了两篇。搭建自己的博客之前看过不少别人搭建的技术博客，隐约发现一个有意思的规律，似乎每个博客的开始段落都会放一张跟技术毫不相干的照片，比如风景照，明星，篮球，动漫等等。我看过的绝大多数技术博客都完美的符合这一规律，原因不详，不明觉厉。平常倒是见过很多餐厅里挂关公、宿舍里挂科比柯南的，不知道是不是同一个道理，emmm……そですね。 所以自己写博客的时候觉得也遵守一下规律，求以后写博客文思泉涌，周末不加班……。 版权声明：本文为博主原创文章，未经博主允许不得转载。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava 1. 前言 上一篇对RxJava做了个简单介绍，在一起读源码前还有一些基础知识要啰嗦两句，个人认为对理解RxJava源码思想有很大的帮助。 2. 观察者模式 RxJava的异步实现，是通过一种扩展的观察者模式来实现的。在之前，当然首先要理解观察者模式。 2.1 观察者模式定义观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 ——《head first 设计模式》 简单举个例子：我们看看报纸和杂志的订阅是怎么回事： 1、 报社的业务就是出版报纸。2、 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。3、 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。4、 只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。 简单一句话概括就是：出版者+订阅者=观察者模式 报社和订阅者组成的模式其实就是观察者模式。翻译成普通话就是：主题(Subject)/被观察者(Observable) + 观察者(Observer) = 观察者模式。 2.2 观察者模式作用重要作用：解耦。也就是将观察者和被观察者解耦。并且解决一对多依赖的问题。 2.3 观察者模式UML类图 2.4 java内置观察者模式源码解析 Java API提供了内置的观察者模式。Java.util包里包含最基本的Observer接口以及Observable类。下面我们来具体看一下他们的源码。 首先是java.util.Observable，这是一个被观察者的类，相当于出版者/社。这里只节选了主要方法和逻辑并进行了注释，方便理解原理。多说一句，其实类里的英文注释讲的非常清楚了，但是由于和中文注释混在一起实在太乱，于是这里把英文的删掉了。英文好的工友可以直接看类里的英文注释。java.util.Observable源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; public Observable() &#123; obs = new Vector&lt;&gt;(); //这里初始化一个存放观察者“们”（Observers）的容器。可以理解为报社里存储订阅者地址的清单。它是线程安全的。 &#125; /** * 这个方法是添加观察者的方法，被addObserver添加进来的不重复的Observer（观察者）放到Vector容器里，这个Observer（观察者）就和当前被观察者产生了依赖。 * 还是用订报纸的模型解释，就是订阅者订报的过程---订阅者把自己的地址发给报社，报社在确认送报清单里这是个新客户之后，把新客户地址加到地址清单里。 */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * 将观察者从被观察者的Vector容器里删除。取消此观察者和被观察者的依赖。 * 订报模型解释—-订阅者通知报社取消订报，报社把该订阅者的地址从地址清单里取消。以后送报就不会送到此订阅者了。 * / public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; /** * 下面两个方法是当被观察者状态变化时调用，主要通过for循环依次调用Vector容器存储的Observer（观察者）的update方法，从而通知并更新全部有依赖的观察者。 * 订报模型解释—-新的报纸出版了（状态变化），按照清单地址依次给每个订阅者送报。 */ public void notifyObservers() &#123; notifyObservers(null); &#125; public void notifyObservers(Object arg) &#123; Object[] arrLocal; synchronized (this) &#123; // if (!changed) if (!hasChanged()) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; /** * 被观察者清空所有有依赖的观察者。 * 订报模型解释——报社拖欠工资，送报员把清单烧了。 */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * 标记被观察者状态已经改变的事实。在notifyObservers之前调用，可以看notifyObservers代码中changed为false时不会执行for循环通知观察者的方法。 */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * 将change状态设置成false，通知观察者方法失效。 */ protected synchronized void clearChanged() &#123; changed = false; &#125; public synchronized boolean hasChanged() &#123; return changed; &#125; /** * 返回已添加进Vector容器的观察者的数量。 * 订报模型解释—当前订报人数。 */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 再来看下java.util.Observer，实现观察者的接口。就是订阅者。java.util.Observer源码解析123public interface Observer &#123; void update(Observable o, Object arg);&#125; 是的，观察者接口就只有这么简单的一个方法，update(Observable o, Object arg)：第一个参数（Observable o）被观察者（主题）本身当做第一个变量，好让观察者知道是哪个被观察者（主题）通知它的；第二个参数（Object arg）传入notifyObservers()的数据对象，如果没有说明则为null。 可以看到，Java里通过Observer接口以及Observable类实现了最基本的观察者模式。通过源码解析我们也可以发现它的实现原理还是非常的简单的，其实是通过维护一个内部数组集合加上接口的回调，却很好的解决了观察者和被观察者解耦的问题。同时，Observable对各方法都加了synchronized关键字(notifyObservers的在方法内)，也就是说，Observable是线程安全的，每次调用方法前都需要取得Observable对象的锁。 3. 总结 在最开始的时候，我们抛出了个概念：“RxJava的异步实现，是通过一种扩展的观察者模式来实现的。”因此这一章节首先带大家回顾了一个基础知识就是常规的观察者模式。我们可以看到，观察者模式是解决对象之间的一对多的依赖问题，而对于RxJava而言，扩展的观察者模式主要解决的是异步实现的问题。这也是我总结出的扩展的观察者模式和常规观察者模式的区别之一。在下一章节会和大家一起学习RxJava的扩展的观察者模式是如何实现的。大家加油。","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"一起读RxJava源码（一）——简介","slug":"一起读RxJava源码（一）——简介","date":"2018-05-12T03:06:21.000Z","updated":"2019-07-01T09:32:28.000Z","comments":true,"path":"2018/05/12/一起读RxJava源码（一）——简介/","link":"","permalink":"https://ten-z.github.io/2018/05/12/一起读RxJava源码（一）——简介/","excerpt":"RxJava已经火了一段时间了，我的项目包括我最近看的很多项目都在用RxJava。之前学习了一些RxJava原理及源码，有了一些感悟，在此做一个系列进行总结。 学无止境，大家加油！","text":"RxJava已经火了一段时间了，我的项目包括我最近看的很多项目都在用RxJava。之前学习了一些RxJava原理及源码，有了一些感悟，在此做一个系列进行总结。 学无止境，大家加油！ 版权声明：本文为博主原创文章，未经博主允许不得转载。 读前注意事项：1.本篇文章创作时间为2017.5.2，由于之前没有个人博客，所以现在才发出来。在发出之前做了些许修改。2.本编文章基于RxJava 1.x。3.由于本人是个Android搬砖工，因此本文仅限于Android上对RxJava的理解和运用，其他类型的工友能看懂主要思想和逻辑即可。4.推荐几篇文章： 最权威：ReactiveX官网官方文档http://reactivex.io/ RxJava 1.x:朱凯（扔物线）《给 Android 开发者的 RxJava 详解》 http://gank.io/post/560e15be2dca930e00da1083#toc_18张磊BARON RxJava系列1~7 https://www.jianshu.com/p/ec9849f2e510 RxJava 2.x:南尘 这可能是最好的RxJava 2.x 教程 https://www.jianshu.com/p/0cd258eecf60 5.本系列文章主要侧重于RxJava基本原理和基本实现的源码解析，对RxJava各种操作符的各种用法可能不会介绍得很全，算是一篇RxJava源码解读入门级的文章。 RxJava其他各种炫酷的用法可以去拜读上面几位大神的文章，写的都很详细。如果还想更深入学习推荐阅读官方文档。 一起读RxJava源码系列：一起读RxJava源码（一）——简介一起读RxJava源码（二）——基础知识:观察者模式一起读RxJava源码（三）——RxJava的基本实现一起读RxJava源码（四）——转换操作符一起读RxJava源码（五）——线程调度一起读RxJava源码（六）——深入浅出：基于波浪事件流和模块化的思路分析RxJava 1. 前言 RxJava应该是从大概15年开始(？大概吧)，被越来越多的开发者关注并学习。至今已然成为很多公司和个人项目的首选，尤其是没有自己网络封装库的公司的首选(emmm…)。比较著名的就是各种博客论坛公众号都在介绍的RxJava+Retrofit+mvp。 虽然目前RxJava 2.x已经出了一段时间了，官方也已经终止对RxJava 1.x的维护。但是我还是没有远见的写了一篇关于RxJava 1.x的文章。主要是因为在自己看源码的那个时间段里RxJava 1.x的文章最多，而RxJava 2.x的文章没有找到通俗易懂适合初学者的。因此本着初学源码，理解为上的原则，还是选择学习RxJava 1.x的源码来学习。当然，不出意外的，首先主要看了最经典的装X必读：朱凯（扔物线）写的《给 Android 开发者的 RxJava 详解》。看了N遍之后，得出了下面的结论: 后来又拜读了张磊大神写的RxJava系列1~7，在掉了几万根秀发以后终于摸到了一些门道——大概就是我的头型还不够圆……以及RxJava源码的一些理解。于是写下了这篇文章，跟着学渣装X慢慢看懂RxJava。 2. RxJava相关概念2.1 先忽略Java，来看下Rx RX，全称是ReactiveX，官网链接在上面的推荐文章里。官网上的第一句话就明确的写出了它的作用：An API for asynchronous programming with observable streams 大概翻译：一种异步编程API，使用（with介词，我觉得翻译成使用比较好）可观察流 Rx的官方定义 这个定义有点抽象，但是也告诉了我们三个事情。1、这是一个API2、这是一个用来实现异步编程功能的API3、实现这个功能使用的是可观察流的方式 下面再来看官网的第二句话和图： The Observer pattern done rightReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming 大概翻译：观察者模式的正确使用ReactiveX是从观察者模式、迭代器模式和函数式编程的最佳思想的组合。 Rx定义的官方解释 所以，上面的可观察流可以理解为是一种观察者模式、迭代器模式和函数式编程的组合。当然起主要作用的我认为是观察者模式，毕竟done right。 再来看官网的最下面一句话：ReactiveX is more than an API, it’s an idea and a breakthrough in programming. It has inspired several other APIs, frameworks, and even programming languages. 大概翻译：ReactiveX不仅仅是一个API，它是编程的一个思想和突破。它启发了其他几个API、框架，甚至是编程语言。 Rx的意义 瞬间高大上了有木有，把ReactiveX升华成了一种思想。思想能干什么？思想能改变世界啊……扯远了，所以这么牛X的框架，就问你： 那我们开始吧。 2.2 所以RxJava是什么 刚刚介绍了Rx，后面加上Java当然就是使用Java语言来编写和使用的Rx。官网上还有其他语言的Rx。比如：RxJS、Rx.NET、RxScala、RxSwift……。本系列的所有文章都是基于RxJava来讲解的。 对于Rxjava是什么。大神们给的一个词是“异步”。“RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.” 大概翻译：RxJava 是Reactive Extensions在 Java VM 上的实现， 是一个用可观测序列(基于观察者模式)来组成异步的、基于事件的程序的库。注：Reactive Extensions：An API for asynchronous programming with observable streams。（Reactive Extensions是用可观测流实现异步编程的API，有基于各种语言的库。RxJava是其中一种。） “It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.”大概翻译：它扩展了观察者模式以支持数据/事件序列，并添加了操作符允许您声明性地将序列组合在一起，同时抽象出对诸如低级线程、同步、线程安全和并发数据结构等。 RxJava在GitHub主页上的自我介绍 简单理解：异步操作库。这个库基于异步可以实现诸多功能，其中最火的莫过于响应式编程，在后面的章节里会稍微介绍一下响应式编程相关基础。 3. RxJava好在哪 好在哪主要是得和别的类库比较。Android一般是和本平台上已经为开发者提供的AsyncTask,Handler等用来做异步操作的类库比较。比较的结果就是：简洁。随着程序逻辑变得越来越复杂，它依然能够保持简洁。 注：以下例子均取自大神朱凯（扔物线）的《给 Android 开发者的 RxJava 详解》一文（不包含表情包），例子确实很通俗易懂，所以本人就不胡编乱造了。直接看。 假设有这样一个需求：界面上有一个自定义的视图imageCollectorView，它的作用是显示多张图片，并能使用addImage(Bitmap)方法来任意增加显示的图片。现在需要程序将一个给出的目录数组File[] folders中每个目录下的 png 图片都加载出来并显示在imageCollectorView中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在UI线程执行。常用的实现方式有多种，这里贴出其中一种： 通过Thread新建线程读取图片，并通过runOnUiThread更新imageCollectorView1234567891011121314151617181920new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(&quot;.png&quot;)) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的：RxJava实现123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(&quot;.png&quot;); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 这里代码看上去行数是变多了，但是逻辑却变得简洁了，用有文化（装X）一点的词形容叫“对仗”。RxJava 实现的是一条从上到下的链式调用，没有任何嵌套。 配合Lambda表达式使用效果拔群：RxJava+Lambda1234567Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(&quot;.png&quot;) &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。 4. 总结 Rxjava简介到这就差不多了，相信大家都了解了Rx的作用和功能，也能感受到RxJava的优势——简洁。在进入正题之前，还有一些基础要熟悉一下。下一篇文章会对基础之一的观察者模式做一个介绍，敬请关注！","categories":[{"name":"Android","slug":"Android","permalink":"https://ten-z.github.io/categories/Android/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://ten-z.github.io/tags/RxJava/"}]},{"title":"Android基于Jenkins+Git+Gradle+七牛云+QR-Code实现自动打包、上传七牛云并生成二维码","slug":"Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码","date":"2018-04-21T10:18:41.000Z","updated":"2018-08-26T07:01:44.000Z","comments":true,"path":"2018/04/21/Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码/","link":"","permalink":"https://ten-z.github.io/2018/04/21/Jenkins-Git-Gradle-七牛-QR-Code实现Android自动打包、上传七牛并生成二维码/","excerpt":"题目很长，本篇文章内容也如题目所示，介绍工作中借助自动化手段，提高团队间工作效率的一种很好的方法。","text":"题目很长，本篇文章内容也如题目所示，介绍工作中借助自动化手段，提高团队间工作效率的一种很好的方法。 版权声明：本文为博主原创文章，未经博主允许不得转载。 对于移动端的开发和测试，一般流程是测试人员向移动端开发人员要测试包，开发通过本地IDE（Android开发一般是Android Studio）打好包后通过各种媒介传给测试人员。测试人员拿到包后开始测试，一但发现bug，会通知开发人员修改，然后再重复上面的过程。 为了简化工作流程，提高效率，可以选择jenkins做持续集成。将jenkins部署在服务器上，通过jenkins实现app自动化打包。这样一来，开发人员每次只需将代码提交到版本控制系统（如git）的远程代码库上，测试人员可以根据自己需求和时间使用jenkins进行自动打包。实现开发与测试的“解耦合”。 网上关于Android开发Jenkins部署的文档有很多，不过绝大部分文档都是上传蒲公英等网站，这些网站能自动生成下载二位码并返回，可以减少部署难度，网上可参考的资料也更多，推荐优先选择这些网站。但是如果你在的公司并没有用蒲公英（比如我目前的公司），而是用的七牛云等没有返回二维码只是可以生成下载链接的网站，那么这篇文章或许能够帮到你更多。 ♨ 综上所述，没钱就要多努力，人丑就要多读书。 特别提示，下面的内容可能图比字多，因为配置这种东西我认为还是图更能说明问题。 1. Jenkins部署 这部分网上资料太多了，本人也是按照网上的教程一步一步配的。这里就不一一复制粘贴写了。可以自行百度，也有几个推荐的网址： http://blog.csdn.net/u011541946/article/details/78267097 http://www.jianshu.com/p/38b2e17ced73 http://blog.csdn.net/mabeijianxi/article/details/52680283 http://blog.csdn.net/fengshi_sh/article/details/50669754 http://www.jianshu.com/p/915c1ae69144 1.1 推荐安装插件 Branch API Plugin build timeout plugin build-name-setter Credentials Binding Plugin description setter plugin Dynamic Parameter Plug-in Environment Injector Plugin fir-plugin（可选） Git plugin（可选） GIT server Plugin(可选) Gradle Plugin Pipeline: Basic Steps Pipeline: Build Step Pipeline: Input Step Pipeline: Nodes and Processes Pipeline: Stage Step Post-Build Script Plug-in SSH Slaves plugin Subversion Release Manager plugin(可选) Timestamper Workspace Cleanup Plugin Subversion Plug-in(可选) （不一定都能用上，反正我是能装的都装了） 2. JDK、androidSDK、androidNDK等配置回到主界面-&gt;系统管理-&gt;全局属性： 配置好JDK（NDK）与PYTHON。注意：1. 相关配置需要Overall权限，在 系统管理-ConfigureGlobal Security 里配置账户权限。2. 这里的键需要和服务器环境变量内的Android SDK/NDK目录的键一致。 2.1 安装Gradle点击系统管理-Global tool configuration gradle可以直接用服务器的安装地址（如果服务器已安装），也可以选择自动安装，自动安装jenkins在第一次打包的时候回会自动下载，因此第一次打包时间会很长。 ♨ 这里有个小问题，如果gradle勾选自动安装，勾选框的上面name这个输入框尽量以后不要改动，亲自入坑测试发现仅仅改动name后，下一次打包时会从新下载gradle（原因是自动安装的目录名就是配置的的name，改动name相当于改了安装路径，gradle会在新的安装路径下重新下载安装）。 3. 创建项目并打包前面主要是在配置环境，环境搭好下面就可以配置项目了。 3.1 创建项目回到主界面-&gt;新建-&gt;构建一个自由风格的项目-&gt;ok: 3.2 git配置进入到刚创建的项目中点击“配置”，找到“源码管理”，选择“Git”。 3.3 构建–Invoke Gradle script Gradle Version:选择系统管理里配置的gradle-nameTasks:填gradle构建命令：clean是打包之前清除一下上一次编译记录。assembleRelease 或者assembleDebug，对应AS里release和debug版的包其他请自行百度gradle构建命令Pass job parameters as Gradle properties:如果需要参数化构建，需要勾选。参数化构建内容在下面一节。 3.4 参数化构建 参数化构建的主要功能是将jenkins里配置的参数注入到Android项目中的配置里，而勾选Pass job parameters as Gradle properties这个选择框可以帮我们侵入到gradle.properties文件中替换相同名称变量的值。达到入侵的效果。 由于build.gradle文件能够直接引用gradle.properties文件中的属性，因此入侵的参数如果要在build.gradle中使用的话可以直接调用。然而我们有些入侵的参数需要在java代码里用到，这就需要用到defaultConfig里面的buildConfigField方法。 上面一大波操作可能有点令人窒息，上干货： 3.4.1 先是参数配置勾选参数化构建流程，选择添加参数: 可选的参数类型有很多，这里只介绍Choice Parameter和Dynamic Parameter。其他参数类型可自行尝试。 Choice Parameter：是单选参数，配置时列出所有参数，用换行隔开，如下图： 配置完成后点击保存，回到项目页面，点击Build with Paramters，可看到刚刚配置的单选效果。开始构建后，所选择的值就会被注入到gradle.properties文件中替换相同名称变量的值。如下图： Dynamic Parameter：这个参数的值会根据你添加的Groovy脚本自动生成。配置方式如图： 其他的参数以及使用方法请自行查阅。 3.4.2 jenkins入侵参数的调用 我们知道参数化构建是将jenkins配置的参数侵入到gradle.properties文件中替换相同名称变量的值。因此，第一步就是要在Android项目下的gradle.properties文件中写入相同名称和初始值。 构建成功后，这里的EXAMPLE的值就会被jenkins上配置的EXAMPLE多选框选中的值替换。因此在程序中可以像使用gradle.properties中的参数一样使用入侵的参数。 build.gradle中调用gradle.properties的参数：build.gradle中可以直接可以调用gradle.properties中被jenkins修改过值的参数。这里以SDK_VERSION相关参数为例，如下图：gradle.properties:build.gradle: java代码中调用gradle.properties的参数：Java代码中调用gradle.properties文件里的参数需要build.gradle文件做一个桥梁，具体就是在build.gradle文件里调用buildConfigField方法。如下图： 这里的buildConfigField就是自定义一个常量，第一个参数表示类型，第二参数表示常量名，第三个参数传入的是值。这里${EXAMPLE}就是传入的gradle.properties里EXAMPLE变量的值。通过这个方法Gradle就会在BuildConfig这个类中加入常量API_HOST，如下图： 通过jenkins构建之后BuildConfig类里的的API_HOST的值就会被jenkins中配置的EXAMPLE的值替换。 下一步，在java代码里中调用BuildConfig.API_HOST，取到jenkins配置的变量的值：1public static String LOGIN_URL = BuildConfig.API_HOST 参数注入在实际工作中还是有很多用途的，比如可以用来配置不同环境、修改某些参数等等。 4. 七牛上传4.1 编译并安装七牛插件qiniu-plugin 经过上面几步出神入化的微操之后，我们已经可以在jenkins服务器上进行打包了，下面就是要将打好的apk上传到七牛云上，方便各位大佬下载（管开发要安装包的都是大佬，反正我是这么认为的）。 将apk上传七牛云有几种方法，Python好的同学可以自行研究下命令行上传。这里介绍一种老少皆宜的方法：使用七牛插件上传。但是，目前在七牛开发者中心-Jenkins七牛插件中已经找不到相关插件了，不过在万能的github上还可以找到源代码：https://github.com/ipy/qiniu-plugin 推荐一个网址可以参考：http://blog.csdn.net/fengshi_sh/article/details/50669754但是该网址里面的很多代码有误，这里亲测并修改了： 下载好源码后，建议修改QiniuPublisher.java文件 1 注释掉System.console().printf(profile.getName() + &quot;/n&quot;) 2 在第107行 123//String keyPath = path.getRemote().replace(wsPath, \"\");//String key = keyPath.replace(File.separator, \"/\");String key = path.getName(); 3 由于java8环境，还要修改pom.xml文件 12345678910111213diff --git a/pom.xml b/pom.xmlindex 0f577be..4d7c73d 100644--- a/pom.xml+++ b/pom.xml@@ -13,7 +13,7 @@ &lt;parent&gt; &lt;groupId&gt;org.jenkins-ci.plugins&lt;/groupId&gt; &lt;artifactId&gt;plugin&lt;/artifactId&gt;- &lt;version&gt;1.509.4&lt;/version&gt;+ &lt;version&gt;1.554.1&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;org.6wind.jenkins&lt;/groupId&gt; 修改完成后，就可以编译了，步骤如下： 在”终端”里执行1234567brew install maven cd /Users/apple/Downloads/qiniu-plugin-master //进入源码文件夹 export MAVEN_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n&quot; mvn hpi:run //会运行起一个模拟环境^q //退出该模拟环境，mvn clean //删除target，第一次无需执行这个 mvn package //打包生成Tagret，新生成的.hpi文件就在target下 最后，将编译好的.hpi导入jenkins插件: 系统管理–管理插件–高级–上传插件然后在增加操作后步骤选项框里就能看到上传到七牛的选项了！ 4.2 七牛设置项（系统管理–系统设置） Accesskey/Secretkey 值可在七牛账户中查看，对应AK和SK 4.3 配置上传到七牛的相关参数增加构建后造作步骤—&gt;上传到七牛 选择上传到七牛后显示如下： 需填写的内容：七牛配置项：系统设置-七牛-设置项名称文件路径：需要上传的文件路径要上传到的 bucket：上传到七牛的空间（文件夹）名称勾选“构建失败则不上传” 上传成功后，七牛官方给出的反馈日志如图 构建后在jenkins构建项目的Console Output里能看到相关日志，证明上传成功。 5 生成七牛下载链接和二维码最终效果如下图，构建完成后会显示在项目主页的构建历史里。 5.1 生成七牛下载链接 由于请求七牛的返回值里没有具体链接，只有目标资源的最终名字。而七牛的bucket文件夹一旦创建，这个bucket的外链默认域名是固定的，因此七牛的链接需要手动把bucket下载链接拼上。（目前七牛bucket文件夹生成的临时域名需要绑定自定义域名，但是在这里并不影响我们的配置，配置了的话换成自定义域名就好。） 链接的展示需要用到：构建后操作—Set build description在这个插件里写好的链接会出现在此项目主页的构建历史里。 使用这个插件之前，需要到系统配置—安全配置中，将MarkUp Formatter修改为Safe HTML，这样展现的二维码和链接才能显示成H5标签，否则会显示成文本。 接下来配置Set build description。 第一行是正则表达式，这里的”key”:”(.*)”是用来匹配七牛返回链接里的”key”:””的值。 第二行是显示的h5代码，这里是生成了能点击的链接，\\1表示引用上面正则里的第一个值。 构建成功后生成这样的下载链接: 5.2 生成下载链接的二维码 由于七牛并不像蒲公英等网站能自动生成二维码，因此需要自己手动去生成。 在gradle版本升级到了4.1以上的时候，由于每次生成文件目录是一样的，而gradle又执行了clean命令，因此每次执行打包命令时output下的目录都会被清理（但是可以节省空间），因此用本地apk的路径生成二维码不太合适。这里选择将七牛的下载链接生成二维码，保证可控时间内链接都有效，而且可以外网访问。 按照正常逻辑来讲，应该是先上传七牛之后再生成七牛下载链接的二维码，毕竟没有上传的时候下载链接应该是不存在的。但是，由于生成二维码需要用到Execute shell这个插件，而这个插件在jenkins中是在“构建”这个模块下配置的，而七牛上传插件是在“构建后操作”这个模块下配置的。如图所示： 也就是说，在上传七牛以前就要生成下载链接二维码！！！ 是的，就是这种令人窒息的操作。方法其实很简单，这里还是用了那个小技巧：七牛的bucket(文件夹)一旦创建，这个bucket的外链默认域名是固定的。 也就是说，七牛的下载链接在上传七牛以前我们就能自己拼好(上传的文件名是自己定义的)，二维码因而也可以在上传之前生成。 下面是具体配置： 需要用到python和qrcode这个库。 第一步：下载安装Python和pipwindows和Ubuntu安装方式有点区别，请自行百度。 命令行输入：pip list 检查是否安装成功 第二步：安装Pillow由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 命令行输入：pip install Pillow 第三步：安装qrcode 命令行输入：pip install myqr 第四步：Jenlins中配置Python环境变量 进入 →系统管理 →系统设置 找到 Enviroment variables 第五步：生成二维码指令进入项目→构建→增加构建步骤，选择Execute shell（Ubuntu），或者Execute windows batch command（windows）,填写qrcode生成二维码的python命令： 格式如下：myqr apk下载链接 -n 二维码命名 -v 1 -l L -d 二维码存储路径具体指令含义详见: https://github.com/sylnsfar/qrcode 第六步：展示二维码 构建后操作 → 增加构建后操作步骤→Set build description在原有七牛下载链接上添加刚才二维码保存的图片路径： 最后点击保存。 在项目页面点击 大功告成！！！！","categories":[{"name":"自动化","slug":"自动化","permalink":"https://ten-z.github.io/categories/自动化/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://ten-z.github.io/tags/Jenkins/"}]}]}